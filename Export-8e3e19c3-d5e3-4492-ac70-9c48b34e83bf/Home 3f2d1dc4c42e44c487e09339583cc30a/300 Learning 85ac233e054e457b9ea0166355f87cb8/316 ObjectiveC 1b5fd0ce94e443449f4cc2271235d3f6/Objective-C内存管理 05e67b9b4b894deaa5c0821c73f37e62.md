# Objective-C内存管理

# 栈

“当程序执行某个方法（或函数）时，会从内存中名为栈（stack）的区域分配一块内存空间，这块内存空间称为帧（frame）。帧负责保存程序在方法内声明的变量的值。在方法内声明的变量称为局部变量（local variable）。”

# 堆

“堆（heap）是指内存中的另一块区域，和栈是分开的。为这两类内存区域分别取名堆和栈，是为了能够形象地描述这两个概念。栈会按后进先出的规则保存一组帧，而堆则包含了大量无序的活动对象，需要通过指针来保存这些对象在堆中的地址。
　　当应用向某个类发送alloc消息时，系统会从堆中分配出一块内存，其大小足够存放相应对象的全部实例变量。”

# 指针变量和对象所有权

“指针变量暗含了对其所指向的对象的所有权（ownership）。
　　•当某个方法（或函数）有一个指向某个对象的局部变量时，可以称该变量拥有（own）该变量所指向的对象。
　　•当某个对象有一个指向其他对象的实例变量时，可以称该对象拥有该实例变量所指向的对象。”

![Untitled](Objective-C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2005e67b9b4b894deaa5c0821c73f37e62/Untitled.png)

## 哪些情况会使得对象失去拥有者

“下列情况会使对象失去拥有者：
　　•当程序修改某个指向特定对象的变量并将其指向另一个对象时。
　　•当程序将某个指向特定对象的变量设置为nil时。
　　•当程序释放对象的某个拥有者时。
　　•当从collection类中（例如数组）删除对象时。
”

## 所有权链（Ownership chains）

因为对象可以拥有其他对象，后者也可以再拥有别的对象，所以释放一个对象可能会产生连锁反应，导致多个对象失去拥有者，进而释放对象并归还内存。

# 内存分配 Alloc

- C结构和Objective-C的一个重要差别：类有方法（method）
- 对象和指针：`Party * partyInstance`这样创建的一个对象其实是创建了一个指向该对象的指针！
- 对某一个类发送`alloc` 的方法，就会在内存中创建该类的一块内存区块，然后还会需要`init`来初始化

[****C语言中关于数据在堆或栈及函数参数类型区别****](C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%A0%86%E6%88%96%E6%A0%88%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB%205743b2d407ce43f0a28e1bb7c653a682.md)

# ARC和内存管理

编写iOS应用时，并不需要记录对象是否应该保留或释放，而只需要通过ARC管理内存，也就是自动引用计数。

## 强引用与弱引用

指针会对其对象产生拥有，但是是否会记录到该对象到拥有计数就决定了该引用是强引用还是弱引用(strong & weak reference)

### **强引用（strong reference**）

只要指针变量指向了某个对象，那么相应的对象就会多一个拥有者，并且不会被程序释放。这种指针特性（attribute）称为**强引用（strong reference**）。

### **弱引用（weak reference）**

程序也可以选择让指针变量不影响其指向对象的拥有者个数。这种不会改变对象拥有者个数的指针特性称为**弱引用（weak reference）**。
　　弱引用非常适合解决一种称为强引用循环（**strong reference cycle**，有时也称为保留循环）的内存管理问题。

### 循环引用（**strong reference cycle）**

当两个或两个以上的对象相互之间有强引用特性的指针关联时，就会产生强引用循环。强引用循环会导致内存泄露。当两个对象互相拥有时，将无法通过ARC机制来释放。即使应用中的其他对象都释放了针对这两个对象的所有权，这两个对象及其拥有的所有对象也无法被释放。
　　因此在编写应用时，程序员必须自己做一些额外的工作，才能帮助ARC解决强引用循环所导致的内存泄露问题。解决强引用循环的途径是将某个指针的特性设置为弱引用。

### 设置强弱引用原则

<aside>
💡 要解决RandomItems的强引用循环问题，需要将新创建的两个BNRItem对象之间的某个指针改为弱引用特性。在决定将哪个指针改为弱引用前，可以先为存在强引用循环问题的多个对象决定相应的父-子关系（parent-child relationship）。确定父-子关系后，就可以让父对象拥有子对象，并确保子对象不会拥有父对象。

</aside>

使用`__weak`关键字，可以将某个变量声明为具有弱引用特性。

具有弱引用特性的指针指向的对象被释放后，指针会自动设置为nil。

```objectivec
_ _weak BNRItem *_container;
```

## @autoreleasepool

可以这样理解：如果一个方法或对象创建了一个新的对象，但是又不想成为这个新对象的持有者，就可以通过向这个新对象发送`autorelease`消息，这样新对象就会被autorealse pool持有，可供使用不会被释放。而这个autorelease pool会在自己被销毁的时候，来减少它所持有的那些对象的计数，从而使得那些对象最终被销毁。

所以如果对象不是通过`alloc`或者`init`来创建，那么在调用的时候应该是已经通过autorelease消息来实现持有了。这样如果你根据情况可能需要长期使用的话，要自己来创建持有方式来保持住这个对象，不然某个时候它会因为autorelease pool被销毁时候也被一起销毁。意思就是自己要的东西需要靠自己来保持住。

例如下面这个范例，调用这个方法会返回一个新建的实例。这个实例本来是在方法内部被item所持有，但是这个方法返回时候item被销毁了，所以返回的这个item需要有别的方式来保持住（不然这个方法就不起作用😂）所以在创建后就通过给这个item对象发送一个`autorelease`的方法，让autorelease pool来保持住这个对象。 

```objectivec
+ (BNRItem *)someItem
　　{
　　BNRItem *item = [[[BNRItem alloc] init] autorelease];
		return item：
	}
@autoreleasepool {
　　// 从someItem方法得到一个BNRItem对象，该方法的方法名没有包含alloc或copy
　　BNRItem *item = [BNRItem someItem];
　　} // 自动释放池被销毁，item变量所指向的对象会被释放”
```

<aside>
💡 autorelease pool 是通过外面的@autoreasepool来产生的。所以main函数内部首先就来一个`@autorealsepool`和一对花括号

</aside>

# 一些需要关注概念

## self & super

因此，在调用父类的初始化方法后，应该先将得到的返回**值赋给self变量**，然后确认该变量是不是nil，如果不是nil，再进行下一步的初始化工作。

## NSArray & NSMutableArray

数组对象只能保存指向Objective-C对象的指针，所以不能将基本类型（primitive）的变量或C结构加入数组对象。

如果要将基本类型的变量和C结构加入数组，可以先将它们“包装”成Objective-C对象，例如NSNumber、NSValue和NSData。

## #import &  @import

“目前只有Apple提供的框架可以使用@import。如果需要导入自己编写的类和框架，只能使用#import。”