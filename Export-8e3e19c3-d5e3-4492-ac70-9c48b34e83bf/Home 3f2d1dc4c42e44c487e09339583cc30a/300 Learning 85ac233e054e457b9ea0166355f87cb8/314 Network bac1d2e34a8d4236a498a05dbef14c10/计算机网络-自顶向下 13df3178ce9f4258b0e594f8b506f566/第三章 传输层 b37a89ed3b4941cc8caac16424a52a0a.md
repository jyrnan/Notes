# 第三章 传输层

# 3.1 介绍

## **进程到进程通信**

传输层协议的首要任务是提供进程到进程通信(process-to-process communication)。进程是使 用传输层服务的应用层实体(运行着的程序)。

## **寻址：端口号**

我们使用 IP 地址来定义本地主 机和远程主机(将在第 4 章讨论)。为了定义进程，我们需要第二个标识符，称为端口号(port number)。在 TCP/IP 协议簇中，端口号是在 0 到 65 535 之间的 16 位整数。

客户程序用端口号定义它自己，这称为临时端口号(ephemeral port number)。

## ICANN范围

ICANN(见附录 D)已经把端口号编码划分为三种范围:熟知的、注册的和动态的(或私有
的)，如图 3-5 所示。

- 熟知端口。端口号的范围是 0~1023，由 ICANN 分配和控制。这些是熟知端口号。
- 注册端口。端口号的范围是 1024~49151，ICANN 不分配也不控制。它们可在 ICANN 注册以防重复。
- 动态端口。端口号的范围是 49152~65535。这一范围内的端口号既不受控制又不需要注册，可以由任何进程使用。它们是临时或私有端口号。

## 无连接和面向连接服务

![Untitled](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled.png)

# 传输层协议

## 发送窗口

发送窗口是一种抽象概念，它定义了一个最大为 2m – 1 的想象的盒子，其中有三个 变量，它们是 Sf、Sn 以及 Ssize。

<aside>
💡 太过细致略过

</aside>

## 3.2.6 因特网传输层协议

图 3-38 中给出了 UDP 和 TCP 这两个传输层协议与其他协议的关系，以及 TCP/IP 协议簇的层 次。这些协议位于应用层和网络层之间，是应用程序和网络操作的中间媒介。
UDP 是不可靠的无连接传输层协议，由于在应用中简单高效而被使用，在那些应用中差错控 制由应用层进程提供。TCP 是可靠的面向连接协议，可用于可靠性重要的任何应用。

![Untitled](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled%201.png)

**UDP 和 TCP 使用的熟知端口**

![Untitled](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled%202.png)

# 3.3 用户数据报协议

用户数据报协议(User Datagram Protocol，UDP)是无连接不可靠传输层协议。

## 3.3.1 用户数据报

UDP 分组称为用户数据报(user datagram)，有 8 字节的固定头部，这个头部由 4 个字段组成，
每个字段 2 字节(16 位)。

![Screenshot 2022-08-03 at 11.37.09.png](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Screenshot_2022-08-03_at_11.37.09.png)

**多路复用与多路分解**
在运行 TCP/IP 协议簇的主机上只有一个 UDP，但可能有多个想使用 UDP 服务的进程。处理 这种情况，UDP 采用多路复用和多路分解。

## 3.3.3 UDP应用

**无连接服务**
如前所述，UDP 是无连接协议。同一个应用程序发送的 UDP 分组之间是独立的。

**典型应用**

下面给出了一些典型应用，与 TCP 服务相比，它们从 UDP 服务中的获益更多。

- UDP 适合于这样的进程:它需要简单的请求-响应通信，而较少考虑流量控制和差错控制。
    
    对于需要传送成块数据的进程(如 FTP)则通常不使用 UDP(见第 2 章)。
    
- UDP 适用于具有内部流量控制和差错控制机制的进程。例如，简单文件传输协议(TFTP)
    
    的进程就包含流量控制和差错控制。它可很容易地使用 UDP。
    
- 对多播来说，UDP 是一个合适的传输协议。多播能力已嵌入到 UDP 软件中，但没有嵌入到
    
    TCP 软件中。
    
- UDP 可用于管理进程，如 SNMP(见第 9 章)。
- UDP 可用于某些路由选择更新协议，如路由选择信息协议(RIP)(见第 4 章)。
- UDP 通常用于交互实时应用，这些应用不能忍受接收报文之间的不一致延迟(见第 8 章)。

# 3.4 传输控制协议

1. 传输控制协议(Transmission Control Protocol，TCP)是一个面向连接可靠的协议。TCP 显式
定义了连接建立、数据传输以及连接拆除阶段来提供面向连接服务。

## 3.4.1 TCP服务

**进程到进程的通信**
像 UDP 一样，TCP 通过使用端口号来提供进程到进程通信。

**流传递服务**
与 UDP 不同，TCP 是一个面向流的协议。另一方面，TCP 允许发送进程以字节流形式传递数据，并且接收进程也以字节流形式接收数 据。TCP 建立一种环境，在这种环境中，两个进程好像由一个假想的“管道”连接，这个管道通 过因特网传送这些进程的数据。

**发送和接收缓冲区**

因为发送和接收进程可能以不同的速度写入和读出数据，所以 TCP 需要用于存储的缓冲区。每一个方向都存在一个缓冲区:发送缓冲区和接收缓冲区。

![Untitled](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled%203.png)

## 3.4.2 TCP的特点

**序号系统**

TCP 在段的头部 采用称为序号(sequence number)和确认号(acknowledgment number)的两个字段。这两个字段 指的是字节序号，而不是段序号。

数据：qi ui ii ii ii i

## 3.4.3 段

在 TCP 中的分组称为段(segment)。

![Untitled](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled%204.png)

一个 TCP 段封装了来自应用层的数据。TCP 段被封装在 IP 数据报中，IP 数据报被封装在数据链路层的帧中。

<aside>
💡 segment → pakage → frame ?

</aside>

## 3.4.4 TCP连接

在 TCP 中，面向连接的传输需要三个过程:连接建立、数据传输和连接终止。

### 三次握手

![Untitled](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled%205.png)

为了表示该过程，我们使用了两个时间序列，每端一个。每个段头部的所有字段都有值，或许它
的某些选项字段也有。但是，我们每次仅表示少数几个必须要知道的字段，如果序号、确认号、控制
标记(仅仅是其中被置位的)和窗口大小等有值，那么我们就表示它们。这个阶段的三个步骤如下。

1. 客户发送的第一个段是 SYN 段。这个段仅有 SYN 标志被置位，它用于序号同步。它占用一个序号。当数据传输开始时，在我们的例子中，客户随机选择一个数字作为初始序号(ISN)。注意，这个段不包含确认号。它也没有定义窗口大小;窗口大小的定义只有当段包含确认号时才有意义。段也能包含一些我们本章稍后讨论的选项。注意，SYN 段是一个控制段并且不携带数据。然而，它消耗一个序号，因为它需要被确认。我们可以说 SYN 段携带了一个假想字节。
    
    > SYN 段不携带数据，但它占用一个序号。
    > 
2. 服务器发送第二个段，两个标志位 SYN 和 ACK 置位的段，即 SYN +ACK 段。这个段有两个目的。首先，它是另一方向通信的 SYN 段。服务器使用这个段来初始化序号，这个序号用来给从服务器发向客户的字节编号。服务器也通过给 ACK 置位并展示下一个序号来确认接收到来自客户的 SYN 段，这里的下一个序号是服务器预期从客户接收的序号。我们将在介绍流量控制那一节看到，因为它包含确认，它也需要定义接收窗口，即 rwnd(客户使用)。因为这个段起到 SYN段的作用，它需要被确认。因此，它占用一个序号。
    
    > SYN + ACK 段不携带数据，但它占用一个序号。
    > 
3. 客户发送第三个段。这个段仅仅是一个 ACK 段。它使用 ACK 标志和确认序号字段来确认收到了第二个段。注意，如果不携带数据，ACK 段没有占用任何序号，但是一些实现允许这第三个段在连接阶段从客户端携带第一块数据。在这种情况下，段消耗的序号与数据字节数相同。
    
    > ACK 段，如果不携带数据，则它不占用序号。
    > 

### 数据传输

![Untitled](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled%206.png)

这里需要注意：服务器回复ACK的标识是基于客户端最后一次数据的序号，也就是10000再+1，所以是ack：10001；同理客户端发送的最后一个ack是基于服务器的数据序号17000+1，所以是回复ack：17001。

可以关注一下P：push标志，表示服务器TCP收到数据立刻推送给服务器的进程（后续可能会深入讲述push标识）

**推送数据**

我们看到发送方的 TCP 使用缓冲区存储来自发送方应用程序的数据流。发送方的 TCP 可以选 择段的大小。接收方的 TCP 在数据到达时也将数据进行缓存，并当应用程序准备就绪时或当接收 端 TCP 认为方便时将这些数据传递给应用程序。这种灵活性增加了 TCP 的效率。
但是，在有些情况下，应用程序并不需要这种灵活性。例如，应用程序与另一方应用程序进行 交互式通信。一方的应用程序打算将其击键发给对方应用程序，并希望接收到立即响应。数据的延 迟传输和延迟传递对这个应用程序来说是不可接受的。
TCP 可以处理这种情况。在发送端的应用程序可请求推送操作。这就表示发送端的 TCP 不必 等待窗口被填满。它创建一个段就立即将其发送。发送端的 TCP 还必须设置推送位(PSH)以告 诉接收端的 TCP，这个段所包含的数据必须尽快地传递给接收应用程序，而不要等待更多数据的 到来。这意味着将面向字节的 TCP 改为面向块的 TCP，但是 TCP 可以选择使用或不使用这个特性。

### 连接终止

交换数据双方的任一方(客户或服务器)都可关闭连接，尽管通常情况下是由客户端发起。当
前大多数对连接终止的实现有两个方法:三次握手和带有半关闭选项的四次握手。

三次握手
当前对连接终止的绝大多数实现是三次握手(three-way handshaking)，

![Untitled](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled%207.png)

和连接的三次握手类似。区别是标志位是F

另外，有一个**半关闭状态**：客户端发送关闭不动态

从客户到服务器的数据传输停止。客户端通过发送 FIN 段实现半关闭连接。服务器通过发送ACK 段确认半关闭。然而，服务器还可以发送数据。当服务器已经发送完被处理的数据时，它发送一个 FIN 段。该 FIN 段由客户端的 ACK 来确认。

连接半关闭后，数据可以从服务器传送给客户端，而确认可以从客户端传送给服务器。客户不能再向服务器发送任何数据。

![清楚的图示](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled%208.png)

清楚的图示

### 打开及关闭窗口

![Untitled](%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BC%A0%E8%BE%93%E5%B1%82%20b37a89ed3b4941cc8caac16424a52a0a/Untitled%209.png)

客户和服务器之间交换了 8 个段。

1. 从客户到服务器的第 1 段(SYN 段)请求连接。这个段声明起始 seqNo = 100。当这个段
到达服务器时，它分配了大小为 800 字节的缓冲区(假设)并设置窗口覆盖了全部缓冲区(rwnd =800)。注意，下一个要到达的字节是 101。
2. 第 2 段是从服务器到客户的。这是 ACK + SYN 段。段使用 ackNo = 101，这表示它期待接
收的字节从 101 开始。它也声明了客户可以设置大小为 800 字节的缓冲区。
3. 第 3 段是从客户到服务器的 ACK 段。注意，客户可以定义大小为 2000 的 rwnd，但是，在
图 3-57 中我们不使用这个值，因为通信是单向的。
4. 在客户设置了服务器指定的窗口大小(800)之后，进程推送 200 字节数据。TCP 客户给
这些字节编号为从 101 到 300。之后，它创建了一个段并发送到服务器。段开始字节数是 101 并且携带了 200 字节。之后客户窗口调整，表示 200 字节数据被发送但是等待确认。当这个段被服务器接收，这些字节被存储，并且接收窗口关闭来表示下一个预期字节是 301;存储字节占据了缓冲区的 200 字节。
5. 第 5 段是从服务器到客户的反馈。服务器确认了多达 300 个字节，含第 300 个字节(预期
接收 301 字节)。这个段也携带了减少后的接收窗口大小(600)。在接收这个段之后，客户从它的窗口中清除确认字节并关闭它的窗口，这表示下一个待发送字节是 301。然而，窗口大小减少到 600字节。尽管分配缓冲区可以存储 800 字节，但是窗口不能打开(向右移动右沿)，因为接收方不允许。
6. 在进程又推送了 300 个字节后，第 6 段被客户发送。段定义了 seqNo 为 301，并包含300字节。当这个段到达服务器，服务器存储它们，但是它必须减少自己的窗口大小。在进程拉 100字节数据后，窗口左边关闭了 300 字节，但是右侧打开了 100 字节。结果是窗口大小只减少了 200字节。现在接收窗口大小是 400 字节。
7. 在第 7 段，服务器确认接收数据，并声明它的窗口大小是 400。当这个段到达客户，客户别无选择，只能再次减少它的窗口，并令窗口大小为服务器通告的 rwnd = 400。发送窗口从左侧关闭 300 字节，并从右侧打开 100 字节。
8. 在进程拉另外 200 字节后，第 8 段也是从来自服务器的。它的窗口大小增加。现在，新的
rwnd 的值是 600。段告知客户，服务器仍然期待 601 字节，但是服务器窗口大小增加到 600。我们需要提及的是，这个段的发送依赖于具体实现所规定的策略。一些实现可能不允许在这个时候通告rwnd;服务器需要在这样做之前接收一些数据。在这个段到达客户之后，客户将窗口打开 200 字节而不关闭。结果是窗口增大到 600 字节。

### 糊涂窗口综合征

如果 TCP 发送一个只包含一字节数据的段，这意味着 41 字节数据报(20 字节 TCP 头部以及 20 字节 IP 头部)仅仅传输了 1 字节用户数据。此时，开销是 41/1，这表示我 们非常低效地使用网络容量。在考虑到数据链路层和物理层开销后这种低效更为严重。这个问题称 为糊涂窗口综合征(silly window syndrome)。

## 3.4.8 差错控制

### 校验和

### 确认

TCP 使用确认方法来证实收到了数据段。不携带数据但占用序号的一些控制段也要确认，但ACK 段是不确认的。

> *ACK 段不占用序号，它不需要确认。*
> 

### 重传

## 3.4.9 TCP拥塞控制

TCP 使用两种不同的策略来处理网络中的拥塞。

### 拥塞窗口

TCP 是使用 IP 服务的端到端协议。路由器中的拥塞是在 IP 域内，并且应该由 IP 解决。然而， 正如我们在第 4 章讨论的，IP 是一个没有拥塞控制的简单协议。TCP 自身需要为这个问题负责。

TCP 使用称为拥塞窗口(congestion window，cwnd)的变量来控制段的发送数量，这个变量 的值由网络中的拥塞情况所控制(我们马上就会解释)。cwnd 变量和 rwnd 变量一起定义了 TCP 中 的发送窗口大小。第一个变量与中间的拥塞相关(网络);第二个变量与终端的拥塞相关。实际窗 口的大小是这两者中的最小值。
实际窗口大小 = minimum (rwnd, cwnd)

### 拥塞检测

TCP 发送方使用两个事件作为网络中拥塞的标志:超时和接收到三次重复 ACK。当接收方发 送三次重复 ACK 时，这意味着一个段丢失，但是三个段已经被接收到。网

### 拥塞策略

TCP 处理拥塞的一般策略基于三个算法:慢启动、拥塞避免和快速恢复。（略）

> 加性增加，乘性减少
> 

## 3.4.10 TCP计时器

为了更平稳地执行操作，绝大多数 TCP 实现使用至少四种计时器:重传、坚持、保活和时间 等待计时器。

### 重传计时器

了重传丢失的段，TCP 使用一种重传计时器(在整个连接期间)处理重传超时(RTO)，即 对一个段的确认等待时间

### 坚持计数器

为了处理 0 窗口大小通告，TCP 需要另一个计时器。如果接收 TCP 声明了 0 窗口大小，那么 发送 TCP 停止传输段，直到接收 TCP 发送一个 ACK 段声明非零的窗口大小。这个 ACK 段可能丢 失。如果这个确认丢失了，接收 TCP 认为它已经完成了工作并等待发送方 TCP 发送更多的段。对 于一个只包含确认的段不存在重传计时器。发送方 TCP 没有接收到确认，并且等待另一个 TCP 发 送确认通告窗口的大小。两端 TCP 可能继续相互等待直到永远(死锁)。

为了更正死锁。TCP 为每个连接使用坚持计时器(persistence timer)。当发送方 TCP 接收一个 窗口大小为 0 的确认时，开启坚持计时器。当坚持计时器到时，发送方 TCP 发送一个特殊的段， 称为探测(probe)。

### 保活计时器

保活计时器(keepalive timer)通常在某些实现中使用，来防止两个 TCP 之间的长期空闲连接。 假设有一个客户与一个服务器建立了连接，传输了一些数据并进入沉默状态。或许客户已经瘫痪。 在这种情况下，连接会永远保持打开。
为了消除这种情况，绝大多数实现给服务器配备保活计时器。每当服务器从客户收到一次数据， 就重置计时器。超时时间通常是 2 小时。如果服务器在 2 小时内没有收到客户数据，那么它发送一 个探测段。如果每 75 秒钟发送一个探测段，一共发送 10 个探测段之后仍无客户响应，那么服务器 就认为客户端出现了故障，并终止这个连接。

### 时间等待计时器

时间等待(TIME-WAIT)(2MSL)计时器在连接终止期间使用。

当 TCP 执行主动关闭并发送最后一个 ACK 时，使用 2MSL 计时器。连接必须保持 2MSL 的时间，从而允许 TCP 重发最后一个 ACK，以防 ACK 丢失。