# Any 和 Some 的区别

<aside>
💡 any和some的**区别**：
any：**存在体**已经**不是数据原来的类型**，而是包在一个存在体中，该存在体既包含原类型数据，也包含该数据符合的协议类型。或者说是一个“第三方类型”
some：**不透明体**本质还是**数据原来的类型**，只是对外表现的是该数据类型符合的协议部分。
**相同**：都是表现出某个协议的特征。

**优先使用some**，因为它是某个具体的类型

</aside>

# Any

对应**存在体**

主要解决协议当做具体类型 pizza：Pizza 和泛型 T：Pizza  pizza： T这种形式的区别。

前者本质是协议作为约束类型，引入了一个extential 物体，存在体物体包住了真实类型，无法进行编译时候的优化

后者本质是一个符合协议的具体类型，所以可以编译时候针对类型进行特化，实现优化

# Some

对应**不透明体**

主要是解决带有associate type或Self的协议的问题，让用户不关心底层的associate type具体是什么，而只是关注作为协议的部分。

因此能访问的也就是作为协议的一些特性。

[Swift 5.7 中的 any 和 some (译) - 掘金](Swift%205%207%20%E4%B8%AD%E7%9A%84%20any%20%E5%92%8C%20some%20(%E8%AF%91)%20-%20%E6%8E%98%E9%87%91%20446c38f64986436d90d227f06ae3e44d.md)

[Swift 中的不透明类型、存在类型以及 some、any 关键字 — zzzwco](Swift%20%E4%B8%AD%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E7%B1%BB%E5%9E%8B%E3%80%81%E5%AD%98%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%20some%E3%80%81any%20%E5%85%B3%E9%94%AE%E5%AD%97%20%E2%80%94%20zzzwco%201289a28190e947758b143229939947f0.md)

[波報 #4 -什麼是抽象？叫你們經理出來](https://pofat.substack.com/p/04)

Swift 中提供了兩種層級的抽象工具，在型別層級的抽象工具是 generic 以及 `some` ，我們需要更多跨物種彈性時的最佳工具，比如到餐廳用餐，而餐廳接受的付款方式是信用卡（genus），但實際上信用上又分成不同銀行分發的卡（species），而 Swift 保證接受到的參數是「某個遵循該 protocol 的**型別**之實例」， 於是乎我們可以這樣寫程式：

```swift
func take(payment: some Payable) -> Result
```

然而值層級的抽象工具是 existential container ，一個包裝著遵循某 protocol 實例的**容器**。值抽象的行為在我們的生活中其實很常見，同樣在餐廳場景裡，常會遇到一些無法忍受事物不依他期待進行的人，受到不如意的待遇後便暴怒拍桌，大喊「叫你們經理出來！」

各位，這正是在進行一個抽象的行為啊！因為他根本不在乎經理是「哪種人」（型別），只在乎對方能不能出來給個交代，而且要求的對方是一個獨立個體（實例），化成程式碼就是：

```swift
protocol 經理 {
  func 出來() -> 交代
}

let 誰都好: any 經理 = 某經理()

誰都好.出來()
```

## Pofat总结

最後分享個人區分 `some` 和 `any` 使用場景的心得：

1. 盡量優先使用 `some`，因為它是真實型別，限制是在同一個 scope 裡 `some` 只能代表某「一」種型別。
2. 當同一個 scope 內需要「多」種型別時，你就會需要 `any` 這個容器，比如可以同時存放 String 與 Int 等滿足 Equatable 的 array： `let equatables: [any Equatable]`