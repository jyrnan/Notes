# 协议

WWDC关于Swift性能的视频，讲了很多协议和泛型内容。

[Understanding Swift Performance - WWDC16 - Videos - Apple Developer](https://developer.apple.com/videos/play/wwdc2016/416/)

使用泛型的时候，希望对泛型有些约束，协议可以满足这个要求

在Swift里面，一个协议表示一组正式提出的要求（requirements)

**只有协议中被要求的方法会被动态派发。**

- 也就是说，当你调用变量上的一个要求的方法时，具体哪一个方法会被使用，是在运行时基于变量的动态类型来决定的。
- 协议扩展中的那些非要求的方法，始终会基于变量的静态类型进行静态派发。”

协议可以通过条件化扩展（conditional extensions）添加额外需要约束的API。例如

```swift
extension Sequence where Element: Comparable {
	public func max() {
		return self.max(by: <)
}
```

协议可以继承其他协议，还可以组合起来形成新的协议

协议的关联类型相当于占位符（就是泛型？）

# 协议目击者

## 协议在背后的工作方式：

当你为一个泛型类型添加了 Equatable 约束之后，只要创建一个对应的具体类型的实例，就会有一个协议目击者传递给它。在 Equatable 的例子中，这个目击者携带的，正是用于比较两个值的 == 操作符。基于要创建的具体类型，编译器会自动传入协议目击者。

下面， 则是通过协议取代了显示目击者（explicit witness）

```swift
extension Array where Element: Equatable {
func allEqual() -> Bool {
	guard let f = first else { return true }
	for el in dropFirst() {
			guard f == el else { return false }
		}
		return true
	}
}
```

> 对于满足一个协议的值或者类型 (或者对于一个满足协议要求的方法) 来说，“目击”这个术语来源于数理逻辑。你可以把它想象成，Int: Equatable 通过它的存在，目击了 Int 满足这个协议的事实 (否则就无法编译了)。
> 

<aside>
🤔 感觉这个目击者有点类似于C++的functor。来实现某些功能。
我们可以主动传递一个结构体来传递目击者，显性的 explicit；
但是如果遵循协议了，则会由编译器自动传递目击者，隐性的 inexplict

</aside>

## 协议中的Self

只不过，相比泛型参数 A，我们可以使用 Self，在协议中它表示实现了协议的类型：

```swift
extension Equatable {
	static func notEqual(_ l: Self, _ r: Self) -> Bool {
		return !(l == r)
	}
}”
```

<aside>
🤔 所以说，[Self](%E5%8D%8F%E8%AE%AE%2024a88853c82649e98657cb962f9d1cda.md)其实也是协议中的泛型指代，代表协议类型本身，但是具体是什么类型，未指定。**这里需要仔细理解一下**

</aside>

## 条件化协议的实现(conditional conformance)

利用where关键词来实现。

通过添加协议约束条件，编译器会自动传递一个协议目击者（来确保协议实现，也提供协议的功能）

## 协议继承

协议可以继承。

“但是，（显式传递目击者和使用协议约束类型）这两种做法并不完全相同。同一种类型可以有无数多个显式目击者，但一个类型只能对协议约束的方法提供一份实现。并且，不像显式目击者可以通过参数手动传递，协议目击者的传递是自动的。
如果允许为一个协议提供多份实现，编译器就需要一些方法找到当前环境里最合适的实现。如果这个过程再加上条件化协议实现，就会更加复杂。为了避免这种复杂性，Swift 不允许我们这样做。

> 译注：为什么同一种类型可以有无数多个显式目击者呢？举个例子：对于 Eq<String> 来说，我们可以有不同的比较字符串相等的逻辑。例如，按字位族比较，按不同的编码比较，或者是其它脑洞大开的比较方法。这些方法，只要创建不同的 Eq<String> 对象，并提供不同的函数定义就好了。因此，对 String 来说，Eq 代表的显式目击者的个数是无限的。并且，我们也可以把不同版本的 Eq<String> 作为参数同时传递给一个函数。而对于通过协议约束的类型，则不具有这样的性质，一个实现了 Equatable 的类型只能提供一份 == 操作符的实现，并且这个实现会被编译器作为协议目击者自动插入到需要 == 操作符的地方。”
> 

# 使用协议进行设计

## 协议扩展

这是一种Swift标准库实现的做法：只要你实现协议的几个少数方法，就可以“免费”收获这个协议通过扩展得到的所有功能。

## 自定义协议扩展

协议扩展不是协议的强制要求。只要被要求的函数会进行动态派发。（如何实现还想不明白）

这个问题的关键就是**只有协议目击者中的方法才能被动态派发到一个具体类型对应的实现**，因为只有目击者中的信息在运行时是可用的。在泛型上下文环境中，调用协议中的非约束方法总是会被静态派发到协议扩展中的实现。

## 协议组合

协议可以组合形成新的协议

```swift
typealias Codable = Decodable & Encodabel
```

## 协议继承

实际上，typealias Codable = Encodable & Decodable 这种写法在语法上，和 `protocol Codable: Encodable, Decodable {}` 是完全一样的。只是别名的写法看上去稍微简洁了一点，它更明确地告诉我们：Codable 仅仅是这两个协议的组合，并没有在组合的结果里添加任何新的方法。

# 关联类型

有些协议需要约束的不仅仅是方法、属性和初始化方法，它们还希望和它相关的一些类型满足特定的条件。这就可以通过关联类型 (associated type) 来实现。

<aside>
🤔 协议的关联类型就是协议的泛型！

</aside>

关联类型可以有默认值，在关联类型声明的地方用等号就可以定义默认值。Collection 有五个关联类型，而它们之中很多都拥有默认值。比如，关联类型 SubSequence 就拥有一个默认的 Slice<Self>：

```swift
public protocol Collection: Sequence {
	associatedtype Iterator = IndexingIterator<Self>
	associatedtype SubSequence: Collection = Slice<Self>
	…
}
```

> 关联类型扮演着占位符的角色，它们在晚一些的时候会被填充上，从这点上来说，关联类型和泛型参数有些类似。
**它和泛型参数不同的地方在于**，**到底是谁在哪里来填充这些占位符**。泛型参数是由类型的用户在他们的代码中使用这个类型时所提供的，而关联类型则是类型的作者 (或者那些正在扩展一个已有类型的人) 在实现协议的时候决定的。
比方说，数组类型的用户可以选择这个数组的元素类型 (例如 Array<Int> 或者 Array<String>)，这是因为标准库的作者把它暴露成了一个泛型参数。但用户无法自定义一个数组的迭代器或者自序列的类型；这些类型在标准库中对 Collection 进行实现的时候就已经确定了。
> 

## Self

在协议的定义或扩展中，self指的就是那些实现了这个协议的类型（不是协议本身），你可以把self想象成一个隐式的一直存在的关联类型。

# 回溯满足协议

当让一个类型满足某个协议时，我们应该始终确保我们至少是这个类型或者这个协议的所有者 (或者同时是两者的所有者)。我们建议你不要让一个不属于你的类型去满足一个不属于你的协议。

例如，在写这篇文章的时候，来自 Core Location 框架的 CLLocationCoordinate2D 并不满足 Codable 协议。尽管我们很容易自己为它添加 Codable 适配，但是如果 Apple 决定让 CLLocationCoordinate2D 实现 Codable 的话，我们的实现就被破坏了。在这种情况下，Apple 可能会选择一种其他的实现方式，结果就是，我们不再能对已有的文件格式进行反序列化。

# 存在体（重要）

协议不能当作一个具体类型来使用。只能用来约束泛型参数。但

```swift
let context: DrawingContext = SVG() //当作具体类型了
```

不鼓励，建议使用any P 语法？

```swift
let context: any DrawingContext = SVG() //当作具体类型了
```

我们可以把 any DrawingContext 看作是类似 `Any<DrawingContext>` 的另一种写法 (假若 Any 是一个泛型类型的话)，也就是一个**带有额外约束的 Any 值**。

当编译器看到 any DrawingContext 时，它会创建一个 (四个字长，也就是 64 位系统中的 32 字节的) Any 盒子，并在其中为类型实现的每个协议添加一个 8 字节的协议目击者。我们可以通过下面的代码来验证这个结果：

```swift
MemoryLayout<Any>.size // 32
MemoryLayout<any Collection>.size // 40
MemoryLayout<any Codable>.size // 48, 因为Codable协议实际是两个协议集合
```

**这个微协议类型的值创建的盒子，也被叫做存在体容器（exitential container）**

<aside>
🤔 用any修饰的容器可以理解成一个盒子，对编译器来看，对象类型就是“盒子”，编译器并不知道盒子里是什么。所以即便盒子里的东西符合某种协议，但是也不能确定使用该协议的方法，例如equitable

</aside>

这是编译器必须要做的事情，因为它需要在编译期确认类型的大小。

不同的尺寸的各种类型都有可能满足某个协议，因此将协议包装到一个存在体容器中，就可以创建一个**固定尺寸的类型，这样编译器就可以在内存中确定它的布局**了。Any 容器的四个字中的三个，会用来直接内联存放一些小的值。如果被**包装的值**大于三个字长，那么编译器就会把它放到堆上，并在盒子里存储一个指针。**第四个字会被用来存放一个指针，它指向被包装类型的类型元数据记录**。这个类型元数据包含了**值目击表**，一些诸如创建、销毁或者复制值的基本的操作，就被包括在这个表内。

> **值目击表**在置顶视频29分钟有解释
> 

“体容器的大小会随着类型实现协议的增多而增长”

举例

```swift
let codables: [any Codabale] = [Int(42), Double(42), "FourtyTwo"]
// 这三个元素共占用144个字节，因为每个元素的大小是48字节。
```

对于 codables 数组中的元素，我们唯一能做的事情，就是调用 Encodable 和 Decodable 中的 API (这是指不用 as，as? 或 is 等运行时类型转换的条件下)。

绝大多数情况下，这个容器对程序员是不可见的。比如，调用 type(of:) 将会返回被包装值的类型，而不是盒子包装本身：

```swift
type(of: codables[0]) // Int”
```

## 对比存在体和泛型

“有时，存在体和带有类型约束的泛型参数是可以交换使用的”

细品区别😂

```swift
func encode1(x: any Encodable) {}
func encode2<E: Encodable>(x: E) {}
```

尽管这两个函数都可以用一个实现了 Encodable 的类型调用，但它们并不完全相同。

- 对于 encode1 来说，编译器会把参数包装到 any Encodable 的存在体容器里。这个包装不仅会带来一些性能开销，如果要包装的值过大以至于无法直接存放到存在体里，就还需要开辟额外的内存空间。可能最重要的是，这还会阻止编译器的进一步优化，因为对被包装类型的所有方法调用都只能经过存在体中的协议目击者表完成。
- 而对于泛型函数，编译器可以为部分或者所有传递给 encode2 的参数类型生成一个特化的版本。这些特化版本的性能，和我们手工去针对每个类型书写专门的函数是完全一样的。而相比 encode1，泛型方式实现的缺点，则是更长的编译时间以及更大的二进制程序。

## 存在体和关联类型

在 Swift 5.6 中，存在体的使用被限制在那些既没有关联类型又不针对 Self 进行要求 (除了 Self 被用在返回类型的情况以外) 的协议里。Swift 开发者们应该对这个长久以来都存在的限制很熟悉了，当看到编译器抱怨 “Protocol ‘P’ can only be used as a generic constraint because it has Self or associated type requirements.” (带有 Self 或关联类型要求的协议 ‘P’ 只能用作泛型约束 ) 这句话时，你遇到的就是这个限制。这个错误最初的原因是由于编译器实现中缺少了一项功能，现在它已经被修复了。因此，在 Swift 5.7 中，这个限制会被去掉，并且任意协议都可以被当作存在体使用了。

<aside>
🤔 部分内容完全看不懂了

</aside>

## 存在体无法遵守协议

协议不能遵守它们自己”在 Swift 社区中被奉为金科玉律。现在，我们已经知道协议和隐式的由编译器生成的协议类型 (也就是存在体) 是不同的东西了们我们可以把这句话说得更精确一些：一个存在体类型不能遵守和“它的”名字相同的那个协议。换句话说，你不能把一个存在体 any P 传递给 `func f<T: P>(_ x: P)` 这样的泛型函数。

## 不要过早使用存在体

一般来说，除非你需要变量装箱所带来的灵活性 (比如在一个集合类型中存储类型相异的值)，否则都应该尽量选择使用泛型。

- 存在体会抹去类型信息，而泛型则会保留它。
- 频繁地把值装箱到存在体容器中，再频繁地把它从容器中取出，本身就对性能不利；
- 此外，过早地抹去类型将不可避免地阻止一些编译器优化。

使用一门类型系统强如 Swift 的静态类型语言的最主要原因之一，就是能给予编译器尽可能多的信息来帮助它完成任务。而不必要的类型消除，恰恰是反其道而行。

# 不透明类型

不透明类型是 API 作者用来在不借助存在体 (它会抹消掉类型信息) 的前提下把具体返回类型隐藏起来的一种手段。不透明类型对应的语法是 **`some MyProtocol`**，它代表“某个满足了所列举出的约束的**具体**类型”的意思。

对于用户来说，底层的具体类型被隐藏了，用户只能通过协议所声明的能力 (这里是 MyProtocol) 来操作这个值。到这里为止听起来和存在体很相似，但是和存在体不同的是，类型系统会保留不透明类型 (所隐藏) 的类型信息。这允许用户在使用不透明类型时能做到一些在存在体上无法做到的事情，比如说使用带有 Self 或者关联类型约束的 API。另外，some MyProtocol 这个不透明类型是满足了协议的，而我们已经看到过，存在体是不满足协议的。相比于存在体，不透明类型总体来说更利于编译器进行优化。

<aside>
🤔 似乎可以理解成：
protocol是一个中间点
any是符合这个协议的**任何其他**类型，所以可以理解成没有类型信息了（范围大）。
some是符合这个协议下**更精准**的类型，所以还是可以保留更具体类型信息，但暂时只表现出协议这个类型信息（范围小），一般用于返回值？

</aside>

<aside>
💡 20230311 补充：any和some其实都是表现出**符合某种协议的特性，都是为了把协议当做类型来用**，但细微差别：
any是一个存在体，是创建了一种符合某种协议的通用类型，具体的值类型则隐藏在这个存在体当中。对外表现出来是符合某个协议的类型。在编译时候由于表现的类型是存在体这种生造出来的通用类型，所以不能针对内部具体值类型进行优化。编译器仅仅能针对存在体这个通用类型进行编译。
some是一个不透明体，于any最大不同就是some其实最终表现是某个具体的基本类型，同时这个基本类型符合指定协议。而且，这里强调的符合协议这个事实，这个类型的主要意义集中在它所符合的协议部分，而对其本身的具体类型并不在意。但是和any不同的是它终究是一个具体的类型了，所以编译时候可以针对该类型进行优化了。

</aside>

## 信息隐藏

“不透明类型在信息隐藏方面有两个作用：(a) 让深层嵌套的泛型更容易使用，以及 (b) 将实现细节隐藏起来。我们会通过一个更大一些的例子来仔细看看这两方面。”

## 不透明类型的规则

- 不透明类型可以出现在函数的返回类型，属性/变量，或者下标中。因为它们是专门关于输出类型的，所以它们也被叫做不透明的结果类型。
- 通常来说约束是某个协议，但它也可以是一个类 (如 some UIView 表示任意 UIView 的子类) 或者所个约束的组合 (some AnyObject & Encodable)。
- 不透明类型的函数必须在所有代码路径返回相同的类型。”

```swift
extension RichText {
// 错误：函数声明了一个不透明类型，但是函数体的返回语句底层类型不匹配。
    func appending2<Other: RichText>(_ other: Other) -> some RichText {
        if other.render().isEmpty {
            return self
        } else {
            return Concat(a: self, b: other)
        }
    }
}
```

- 不透明类型的函数必须在每次调用时都返回相同的具体类型”

```swift
func randomNumber() -> some BinaryInteger {
    Int16.random(in: 1...20)
}

let a = randomNumber()
let b = randomNumber()
a + b

//“如果 randomNumber 返回的是 any BinaryInteger 存在体的话，上面的代码将导致错误，因为 + 操作符只被定义在了相同类型的操作数上，而存在体可以把任意满足协议的类型装箱。”
```

<aside>
🤔 any 和 some的区别哦

</aside>

- 你可以通过动态转换还原出具体类型。**不透明类型只被静态类型系统所知，在运行时它们不做任何表达。在一个不透明值上调用 type(of:) 会返回它实际的具体类型。要测试一个不透明值是否是某个具体类型，你可以使用 is 或者 as? 操作符：

[Understanding the "some" and "any" keywords in Swift 5.7 - Swift Senpai](https://swiftsenpai.com/swift/understanding-some-and-any/)

# 类型消除器

尽管我们无法为带有 Self 或关联类型约束的协议创建存在体，但我们可以编写一个执行类似功能的函数，叫做：类型消除器 (type erasers)。

“我们已经看到存在体就是一种类型消除的形式了。由于目前的限制，存在体只对那些没有 Self 或关联类型要求的协议起作用，有时候我们会想要编写一个类型，它能够执行类型消除的任务，同时不受到存在体那样的使用限制。我们把这些类型叫做 (手动) 类型消除器。就算是 Swift 5.7 中更加灵活的存在体，也不能覆盖所有的使用场景 (即那些需要保留一个或多个关联类型的类型消除)，所以至少在一段时间里，编写手动的类型消除依然是有价值的。”

<aside>
🤔 剩下的没看懂……

</aside>