# 结构体和类

# 值类型和引用类型

结构体和类的根本区别

**值类型**的特征就是变量和值之间的这种直接关系：在变量的背后，值 (也可以说是值类型的实例) 直接保存在变量指向的内存位置。

<aside>
💡 符号 对应 内存位置

</aside>

**引用类型**的本质：变量不含有“事物”本身 (例如，UIView 或 URLSession 的实例)，而是持有一个对“事物”的引用。其他变量也可以含有对同一个实例的引用，并可以通过任意一个指向它的变量对其做修改。具有这些特性的类型被称为具有引用语义 (reference semantics)。”

<aside>
💡 一个引用类型变量含有一个指针，指向在内存中某个地方真正的实例 实锤

</aside>

# 可变性

用let声明一个变量，意味着在初始化后就不能改变它的值了。

要理解在属性和变量上用 let 和 var 的所有不同组合的关键是要记住两点：

- 类型为类的变量的值，是一个指向实例的引用；
- 类型为结构体的变量的值，是结构体实例本身。
修改一个结构体的属性，即使修改的是多层的嵌套属性，都等同于给变量赋值一个全新的结构体实例。”

## 可变方法

在结构体上用 func 关键字定义的普通方法，是不能修改结构体的任何属性的。**这是因为被隐式传入的 self 参数，默认是不可变的**。我们必须明确地使用 mutating func 关键字来创建一个可变方法：

```swift
struct Struct {
	var someProperty: Int = 0
	mutating func mutatingMethod() { 
		self.someProperty += 1
	}
} //在可变方法中，我们可以认为 self 是一个用 var 声明的变量，所以也就可以修改那些在 self 中，用 var 声明的属性。
```

> 属性和下标的 setter 都是隐式的可变方法。在极少数的情况下，你会希望使用一个不可变的 setter 来实现计算属性，例如，你的结构体封装了一个全局资源，而相应属性的 setter 只是去修改这个全局状态。这个时候，你可以用 nonmutating set 来标注相应的 setter。编译器允许你在一个 let 常量上调用此类 setter。
> 

## inout参数

函数的参数默认就像是let变量一样，是不可改变的。所以引入inout关键词，使得传入的参数具有可修改性。条件：

- 传入的参数变量必须是var定义
- 用&符合在变量名前

> 虽然 & 符号可能会让你想起 C 和 Objective-c 中的取址操作符，或者是 C++ 中的引用传递操作符，但在 Swift 中，其作用是不一样的。**就像对待普通的参数一样，Swift 还是会复制传入的 inout 参数，但当函数返回时，会用这些参数的值覆盖原来的值。**也就是说，即使在函数中对一个 inout 参数做多次修改，但对调用者来说只会注意到一次修改的发生，也就是在用新的值覆盖原有值的时候。同理，即使函数完全没有对 inout 参数做任何的修改，调用者也还是会注意到一次修改 (willSet 和 didSet 这两个观察者方法都会被调用)。
正如我们在函数一章中解释过的那样，编译器会在安全的时候，把复制操作优化掉，转而变成传递引用。
> 

# 生命周期

结构体要简单得多，因为它们不会有多个所有者，它们的生命周期，是和含有结构体实例的变量的生命周期绑定的。当变量离开作用域时，其内存将被释放，结构体实例也会被销毁。🤔

## 弱引用

在 Swift 里，弱引用变量是归零 (zeroing) 的：一旦所指向的对象被销毁，变量会自动被设置成 nil。这也是为什么弱引用变量必须是可选值的原因。

## Unowned引用

对于 unowned 引用，我们的责任是，确保“被引用者”的生命周期比“引用者”要长。

# 在结构体VS类选择

类可以用来实现结构体，但是反之不行

# 具有值语义的类

- 把类的所有属性变成let
- 把类设置final无法继承

# 具有引用语义的结构体

在结构体中加入引用属性，多个结构体的属性都会指向同一个引用对象。对结构体该属性所指向的对象进行修改，会导致所有持有该引用的结构体并与之相关内容发生变化。（例如某个计算属性依赖于该引用对象）

# 写时复制

其实结构体复制时候内部的大量数据是通过指针来共享的，仅当其中的一个结构体需要改动到这部分共享数据时候，才会激活写时复制，将共享的数据复制一份新的供需要修改的结构体进行修改。而那些仍不需要修改的结构体会继续共享可以共享的数据

<aside>
💡 所有，结构体内部拥有大量数据时候其实还是靠指针来实现的。为了实现COW，所以会有一个内部引用计数

</aside>

> 实际上，我们是放弃了值类型不需要引用计数的这个优点，来减轻值类型的复制语义这个特性所可能带来的成本。
> 

## 权衡利弊

SwiftNIO 项目中就有一个实际的例子：在这个项目中，一个 HTTP 请求就是用结构体来实现的，它包含了多个属性，像是 HTTP 方法和头。当这样一个结构体被复制时，不仅要复制它所有的字段，而且所有内部的数组，字典和字符串的引用计数也都会增加。当传递这种类型的值时 (这种操作很常见)，这种开销会导致性能的显著下降，而用类实现它的话，性能会好很多，因为一个对类的引用，要比 HTTP 请求结构体的所有字段更小，并且也只需要更新这一个引用的引用计数。

## willSet的影响，没有看懂