# 泛型

参考阅读：

[Swift 中的不透明类型、存在类型以及 some、any 关键字 — zzzwco](../Swift%20%E4%B8%AD%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E7%B1%BB%E5%9E%8B%E3%80%81%E5%AD%98%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%20some%E3%80%81any%20%E5%85%B3%E9%94%AE%E5%AD%97%20%E2%80%94%20zzzwco%201289a28190e947758b143229939947f0.md)

泛型编程是一种能保持类型安全性的代码重用技术。可以认为是多态的一种形式。

至少有四种不同的概念，可以归纳到多态编程这个范畴里：

- 我们可以定义多个同名但是类型不同的函数。例如，在函数这一章，我们定义了三个不同的 sortDescriptor 方法，它们每个都有不同的参数类型。这种用法叫做**重载 (overloading)**，或者更技术地说，这是一种 (为了解决排序这个问题而特别设置的) **专属多态 (ad hod polymorphism)。**
- 当一个函数或方法接受类 C 作为参数的时候，我们也可以给它传递 C 的派生类，这种用法叫做子**类型多态 (subtype polymorphism)。**
- 当一个函数 (通过尖括号语法) 接受泛型参数的时候，我们管这个函数叫做**泛型函数 (generic function)** (这和泛型类型类似)。这种用法叫做**参数化多态 (parametric polymorphism)。**这些泛型化的参数，也被叫做**泛型 (generics)。**
- “我们可以定义一个协议并让多个类型实现它。这是另外一种更加结构化的**专属多态**。

# 泛型类型

我们可以把 Optional (不带尖括号的) 当作一个类型构建器 (type constructor)：给它传递一个具体类型 (例如：Int)，它就会创建一个新的具体类型 (例如：Optional<Int>)。

- Optional 用泛型参数抽象它包装的类型。
- Result 有两个泛型参数：分别表示成功和失败这两种结果对应的值的类型。
- Unsafe[Mutable]Pointer 用泛型参数表示指针指向的内存的类型。
- Key paths 中使用了泛型表示它们的根类型以及路径的值类型。
- 各种表示范围的类型，使用了泛型表达它们的元素类型 (Bound)。

# 泛型和Any

泛型和 Any 可以被看作类似的用途，但它们有截然不同的表现。

在没有泛型的编程语言里，Any 通常用来实现和泛型同样的效果，但是却缺少了类型安全性。这通常意味着要使用一些运行时特性，例如内省 (introspection) 或动态类型转换，把 Any 这种不确定的类型变成一个确定的具体类型。而泛型不仅能解决绝大部分同样的问题，还能带来编译期类型检查以及提高运行时性能等额外的好处。

<aside>
🤔 **对于任何数据，终究是必须要指定类型的，指定类型其实也就是指定在内存中长度，所以**：
* Any代表是即便编译不确定的任意类型，但是需要在运行时候转换成某种具体类型
* 泛型虽然代码期不指明具体类型，但是在编译时候一定会确定某种具体类型

</aside>

泛型其实是表达了一种类型之间的关系。但是Any因为它可以代表任意类型，所以不会有类型之间的关系。例如：

```swift
extension Array {
    func reduce<Result>(_ initial: Result,
                        _ combine: (Result, Element) -> Result) -> Result
}
// 这里看出前后中Result是某种具体类型。initial和combine输出以及最终输出都是同一类型

extension Array {
    func reduce(_ initial: Any, _ combine: (Any, Any) -> Any) -> Any
}
//这里的Any是不能反映出前后一致的关系的，例如第一个参数和返回值的关系？
```

> 从某种意义上来说，一个函数或方法的泛型程度越高，它能做的事情就越少！
> 

# 泛型的静态派发

Swift 支持函数重载，也就是说，可以存在多个同样名字但参数和/或返回类型不同的函数。编译器决定调用哪个函数的过程，被称为重载解析 (overload resolution)。对于每个调用点，编译器都遵循一套规则，这套规则可以被归纳为“为给定的输入和结果类型挑选最具体的那个重载”。重载解析总是在编译期间静态地发生；动态运行时的类型信息在其中不扮演任何角色。

“好的方法是使 format 函数成为一个协议的要求，并将泛型参数约束到这个协议中。这样的方法会使用动态派发，**因为协议要求是动态派发的**。”

# 泛型的工作方式（需要反复全文看）

这样的泛型函数

```swift
func min<T: Comparable>(_ x: T, _ y: T) -> T {
	return y < x ? y : x”
}
```

“编译期间编译器都还不知道的类型。这意味着，编译器无法为这个函数生成代码，因为它缺少了三个必要的信息：

- 类型 T 的值的大小 (包括参数和返回值)。
- 如何复制和销毁类型 T 的值 (比如，它们是否需要引用计数)。
- 需要调用的指定重载的 < 函数的地址。

**Swift 通过向泛型代码引入一层间接层来解决这些问题：**

- 使用指针来传递大小未知的函数参数，返回值以及变量。
- 对每个泛型类型参数 T，编译器会把 T 的类型元数据 (type metadata) 传递到函数中去。类型元数据记录包含了类型的**值目击表 **(value witness table, VWT)****和其他一些东西。**VWT 提供了对类型 T 的值的进行基本操作的函数，比如如何复制，移动，或者销毁一个值**。对于一些像是 Int 遮掩的个简单值类型，它们可能是无操作或者内存复制，但对于引用类型来说，可能就会包含引用计数的逻辑。VWT 还对类型的内存布局 (大小和对齐) 进行了记录。
- 对于 T 上的每个约束，编译器都会将一个**协议目击表 (protocol witness table, PWT)** 传递给函数。PWT 是一个记录有协议要求方法的 vtable。它用来在运行时将函数调用动态地派发到合适的实现去。在我们的例子中，对于满足了 Comparable 的T，PWT 会提供正确的函数。

“在伪代码里，编译器为 min 函数生成的指令看起来类似这样：

```swift
void func min(_ x: OpaquePointer, _ y: OpaquePointer,
returnValue: OpaquePointer, // caller-allocated storage
meta_T: TypeMetadata, T_is_Comparable: VTable)
{
	let result = T_is_Comparable.lessThan(y, x, meta_T, T_is_Comparable)
	if result {
		metadata_T.vwt.copyInit(returnValue, from: y, meta_T)
	} else {
		metadata_T.vwt.copyInit(returnValue, from: x, meta_T)
	}
}
```

因为 T 的内存布局在编译期间是未知的，因此包括返回值在内，所有的值都要通过指针传递。编译器通过 PWT 来调用 y < x，然后通过 **VWT** 来把 y 或者 x 复制到存储中并最后返回。

> *上面使用指针来传递泛型值的伪代码可能会让你觉得 Swift 会使用装包 (boxing) 的方式来代表尺寸未知的值，但其实不是这样的。**指针的存在，是因为编译器无法为可变大小的值申请 CPU 寄存器的空间，但是这些指针所指向值依然可以是直接生存在栈上的，这不会带来额外的开销。**这种做法比 boxing 要高效得多，特别是在处理集合类型的时候：一个泛型值的数组 [T] (当 T == Int 时) 所拥有的运行时内存布局和具体类型的数组 [Int] 完全一样。泛型代码使用间接操作元素的方法来使用这个数组，但数组中元素自身依然是紧凑排列，在内存中连续的。这个设计为 CPU 缓存的缓存局部性优化提供了最大的可能性。*
> 

# 泛型特化

间接层的引入带来泛型的消耗

在许多情况下 Swift 编译器可以使用一种叫做泛型特化 (generic specialization) 或者称作单态 (monomorphization) 的方式，来完全去除掉这个开销。 

使用 Int 为 min<T> 进行特化后的版本看起来就像这样：

```swift
func min(_ x: Int, _ y: Int) -> Int {
	return y < x ? y : x
}
```

泛型特化不仅仅节省了虚拟派发的开销，它也开启了更多优化的可能。比如内联 (inline)，如果没有特化的话，间接层将会是一个很大的障碍。

当你在编译代码时开启优化 (命令行中使用 swiftc -O 或者 SwiftPM 中使用 swift package build -c release) 时，优化器将会针对它所能看到的信息，为你的泛型类型和函数创建特化版本。

“关于特化要记住的是，只有当优化器在编译调用侧时可以看到泛型类型或者函数的完整定义的情况下，特化才会发生

- 打开**“全模块优化” (whole module optimization)。**在这个编译模式下，当前模块的所有文件都会在一起进行优化。除了泛型特化，全模块优化也会开启其他重要的优化策略。比如说，优化器会识别出那些在整个模块中没有子类的 internal class。因为 internal 修饰符确保了这个类不会被模块外看到，这也就意味着编译器可以把这个类的所有方法由动态派发替换成静态派发。
- 将泛型函数标记为 @inlinable 以便其他模块使用。这个标记会把函数体也作为模块接口的一部分进行导出，其他模块引用它时，优化器就也能看到这些代码。在这种情况下，当调用者进行编译时，虽然包含泛型函数的模块已经被编译过了，但是优化器仍然能生成一个该函数的特化版本并把它放到调用模块中。我们的 min 函数就拥有 @inlinable 标签：

```swift
@inlinable
func min<T: Comparable>(_ x: T, _ y: T) -> T {
	return y < x ? y : x
}
```

> 将某个东西进行内联，对于像标准库这样的 ABI 稳定的库来说，是一个巨大的承诺，因为这会让更改实现或者修复 bug 变得不可能。但是如果是对于总是会一同进行编译或者重新编译的文件来说，是不需要考虑这些的
> 

> Swift 对泛型的编译模型非常特殊，它作为桥梁，填充了两类不同语言之间的空隙：一头是 C++ 和 Rust 这样的，把所有东西都进行特化的语言；另一头是像 Java 这样，只把泛型作为类型检查，而在运行时通过包装将它抹去的语言。抛开性能方面的考量，Swift 的方式允许对泛型函数或类型在声明侧和客户端的使用侧进行分别编译。这对 Apple 来说是一个重要的功能，因为它允许 Apple 在它的 SDK 中以二进制的方式搭载 Swift 书写的框架。
>