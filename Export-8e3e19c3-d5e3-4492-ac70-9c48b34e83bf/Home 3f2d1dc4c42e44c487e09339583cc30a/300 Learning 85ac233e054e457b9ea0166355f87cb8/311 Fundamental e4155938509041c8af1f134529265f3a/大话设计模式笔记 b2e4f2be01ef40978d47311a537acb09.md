# 大话设计模式笔记

# 面向对象基础（基于C#）

## A.5 属性与修饰符

在C#中，有字段和属性的概念之分：

- **字段**是类中真正存储数据的变量，往往是private的，仅供类内部使用。相对于OC里面的Instance variety
- **属性**是对内部**字段**的调用和引用，往往是public，供外部使用。相当于OC的Property

## A.7 继承

### 三个范围属性特征

1. public：可以被其他类访问
2. private：只能被类内部成员访问
3. protected：对子类完全公开，对其他类不公开

### Base关键字

子类可以继承父类各种属性和方法等等，但是对于构造方法只能调用，不能被继承。对于调用父类的成员，可以用base关键词

> 两个类之间是“is-a”的关系的时候，可以考虑用继承；而如果是‘has-a“的关系的时候就不适合用继承，例如人有手，机场有飞机
> 

## A.8 多态

多态表示不同的对象可以执行相同的动作，但是通过它们自己实现的代码来执行

### 虚方法

为了使子类的实例完全接替来自父类的类成员，父类必须将该成员声明成为虚拟的，这是通过在该成员返回类型之前添加**virtual**关键词来实现

### 方法重写Override

子类将父类的实现替换成自己的实现

### 用法

声明的对象是父类，但是实例化的是子类。这样才能实现多态

**多态的原理是方法调用的时候，无论对象是否被转换成其父类，都只有位于继承链最末端的方法实现被调用。**

**也就是说虚方法是按照其运行时类型，而不是按照编译时类型进行动态绑定调用的。**

## A.10 抽象类

C#允许吧类和方法声明为abstract，即抽象类和抽象方法

- 抽象类不能实例化
- 抽象方法必须被子类重写；抽象方法没有方法体
- 类中如果包含抽象类，则必须被定义为抽象类

> 抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的，所以在一个以继承关系形成的等级结构里面，树叶节点应该是具体的类，而树枝节点均应当是抽象类。
> 

## A.11 接口（协议）

接口是吧隐式公共方法和属性组合起来，以封装特定功能的一个集合。一旦实现了接口，类就可以支持接口所指定的所有属性和成员。声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式

所以接口不能实例化，不能有构造方法和字段，不能有修饰符

实现接口就必须实现接口中所有的方法和属性

一个类可以支持多个接口，多个类也可以支持相同的接口。

接口的命名需要前面加上大写字母“I”， 用interface 声明

### 抽象类和接口的区别

**表现方面：**

抽象类可以给出一些成员的实现，接口却不包含成员的实现，

抽象类的抽象成员可被子类部分实现，但是接口的成员需要实现类完全实现

一个类只能继承一个抽象类，但可实现多个接口等

**另外：**

- 类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象
- 如果行为跨越不同类的对象，可以用接口；对于一些相似的类对象，用继承抽象类。实现接口和继承抽象并不冲突
- 从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知道子类的存在，方法如何实现还不确认，预先定义。

## A.12 集合（类似于Collections）

### ArrayList

类似于Array，实现了IList接口。

ArrayList不是类型安全的，在其内部所有的元素都是object类型，所以所有数据都需用object对象封装。缺点是所有操作都存在一个“装箱”“拆箱”的操作。

## A.13 泛型

就是具有占位符（类型参数）的类， 结构，接口和方法。这些占位符是类，结构，接口很方法所存储或使用的一个或多个类型的占位符。一般通过后面加<T>来实现。

<aside>
💡 其实就是通过一个占位符来约束所指定的类型，占位符指定了类型，就避免了“装箱”“拆箱”的操作

</aside>

## A.14 委托与事件

<aside>
💡 和OC的代理还是有些差别

</aside>

委托是对函数的封装， 可以当作给方法的特征指定了一个名称；而事件则是委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程？

<aside>
💡 委托可以看作是对函数的抽象，是函数的 ‘类’，委托的实例将代表一个具体的函数。

</aside>

- delegate：委托是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为
- event：而事件是说在发生其他类或对象关注的事情，类或对象可以通过事件通知它们

```csharp
public delegate void CatShoutEventHandler(); //定义一个委托

public event CatShoutEventHandler CatShout; //定义一个事件，和上面委托关联

//使用
cat.CatShout += new Cat.CatShoutEventHandler(mouse.run) // 在某个对象（cat）中把cat的CatShout事件和mouse.run登记联系起来了

//然后在Cat.Shout方法中触发CatShout事件
...
public void shout()
{
	...
	if (CatShout != null)
	{
		CatShout(); //如果有登记事件，则执行该事件，也就是通知执行事件对应的委托登记的方法：mouse.run
	}
}
```

还可以更近一步通过设置委托中的参数，一般是sender物件和事件参数args，通过二者传递到需要委托执行的方法中。事件参数的继承`EnventArgs`，它是包含事件数据类的基类。

因此event，delegate和登记方法都有同样的参数，例如：

```csharp
public delegate void CatShoutEventHandler(object sender, CatShoutEventArgs args)
...
//发送事件时候，创建这两个参数this, e，并传入事件中
...
catShout(this, e);
...
//注册的Mouse类中的方法同样也是要接受这两个参数，从而实现了参数的传递
public void Run(object sender， CatShoutEnventArgs args) {...}
```

[第十四章 观察者模式](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09.md) 中也详细讲述了这个关系

# 第一章 简单工厂模式

## 1.11 UML类图

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled.png)

### 聚合关系 Aggregation

一种弱的“拥有”关系， A可以包含B，但是B不一定是A的一部分。例如大雁和雁群

### 合成关系 Composition

一种强的“拥有”关系， 体现了严格的部分和整体的关系，部分和整体的生命周期一样长。例如鸟和翅膀。生成鸟的时候，就同步生产翅膀，它们的同时生成。

```csharp
class Bird
{
	private Wing wing;
	public Bird()
	{
		wing = new Wing(); //同步生成
	}
}
```

### 依赖关系 Dependency

### 工厂模式

工厂模式解决对象创建的问题

# 第二章 策略模式

策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。

策略模式是一种定义一系列算法的方法，从概念上来讲所有这些算法完成的工作都是相同的工作，只是实现不同。它可以以相同的方式调用所有的算法，减少了算法类与使用算法类之间的耦合。

策略模式的Stratagy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这其中的公共功能。

策略模式有助于简化了单元测试，因为每个算法都有自己的接口，都可以通过自己的接口单独测试。

当不同的行为堆砌在一个类中，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句

策略模式就是用来封装算法的，但是实际上它可以封装几乎任何类型的规则。只要在分析过程中抬到不同时间应用不同的业务规则，就可以考虑使用策略模式来处理这种变化的可能性

# 第三-五章 SOLID原则

## 单一职责原则

> 就一个类而言，应该仅有一个引起它变化的原因。
> 

如果一个类承担的职责过多，就等于被这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的破坏。

软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能想到多余一个动机区改变一个类，那么这个类就具有多于一个的职能

## 开放-封闭原则

> 软件实体（类、模块、函数等等）应该可以扩展，但是不可修改
> 
> - Open for extension
> - Close for modification

### 针对变化的方法

在最初编写代码的时候，假设变化不会发生。发生变化的时候，我们就创建抽象来隔离以后发生的同类变化。

例如在编写加法后需要增加新的需求，例如减法。那就创建一个抽象的运算类，来实现此抽象类下的加分、减法子类，甚至更多运算法则都成为新的子类。

<aside>
💡 这样面对新的需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码

</aside>

了解的变化的时间越短越好，抽象越早越容易。但是又要避免过于刻意抽象，拒绝不成熟的抽象。

## 依赖倒转原则

> 高层的模块不应该依赖底层模块，两个都应该依赖抽象
> 
> 
> 抽象不应该依赖细节。细节应该依赖抽象
> 

应该通过协议等抽象来定义出接口，依赖的关系是接口，而不是具体的实现

*结合下面的原则深入理解*

## 里氏代换原则

> 子类型必须能够替换掉它的父类型
> 

只有子类可以替换掉父类，而软件单位的功能不受影响，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。

<aside>
💡 依赖倒转可以说是面向对象编程设计的标志，用那种语言来编写程序并不重要，如果编写时候考虑的都是如何针对抽象编程而不是细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之就是面向过程化的设计了。

</aside>

# 第六章 装饰模式

> 其实就是利用类的继承性，通过创建基类的子类，在子类内部包含基类，**再通过override原方法中调用基类的方法来实现子类的同名方法**，同时可以在这过程中添加相当于装饰功能的指令。
> 

值得注意的是基类Component一般用来定义基本接口功能。

ConcreteComponent来添加更多职责。

装饰器Decorator基于基类的子类，但并不是一步到位的简单子类；而是先创建装饰器的抽象类，在在此抽象类下去近一步子类化。但是这一步整体可以看做是原基类的一个大“子类”

Decorator类里面持有Component类，其operation操作就通过调用Component的同名方法来实现。

<aside>
💡 这里我们可以看出其实也体现了依赖倒转原则和里氏替换：依赖的是一个高层抽象，例如Decoratior里面持有的是Component这个抽象基类，因此是可以通过替换成更具体的ConcreteComponent来实现更加具体的功能？

</aside>

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%201.png)

用Swift实现的代码

```swift
//对象接口基类
class Component {
    func operation() {
        print("base operation")
    }
}

//装饰抽象类，继承至Component，是装饰器的基类
class Decorator: Component {
    let component: Component
    
    init(base: Component) {
        self.component = base
    }
    
    override func operation() {
        component.operation() //调用基类的操作来实现方法
    }
}

//装饰器的具体子类，通过对基类接口添加更多的属性和方法了实现装饰作用
//可以自定义自己的属性或方法来丰富功能
class DecoA: Decorator {
    override func operation() {
        print("decoA operation")
        component.operation()
    }
}

let deco = Decorator(base: Component())
let decoA = DecoA(base: deco)
decoA.operation()
```

# 第七章 代理模式

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%202.png)

## 关键点

需要定一个共用接口的抽象类，真实类和代理类都是这个抽象类的子类

代理类持有真实类，并通过调用真实类的方法来实现自身的方法

# 第八章 工厂方法模式

## 和简单工厂模式的区别

简单工厂模式把生成不同类的判断代码从client移动到了工厂类，通过简单工厂类来产生不同的目标类（例如执行不同运算操作的类）来供使用。但是其缺点是：

> 如果需要修改/增加不同的目标类，就需要修改工厂类的代码，这违背了开放/封闭原则，所以需要对其进一步优化：
> 

通过对工厂类进一步抽象创建一个工厂的接口，再对此抽象类进行不同的子工厂类，用来产生不同的的目标类。这样在客户端可以选择不同的子工厂类来生成相应的目标类。

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%203.png)

# 第九章 原型模式

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

一般是通过实现一个`+Clone()`方法

## 浅复制与深复制

Clone：浅复制 

copy：深复制

# 第十章 模版方法

> 定义一个操作中算法的骨架，而将一些步骤的具体实现延迟到子类中实现，这样可以保证不改变一个算法的结构即可重新定义该算法都某些步骤可以特定化
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%204.png)

### abstractClass

这是一个抽象类，其作用是定义出模版方法，这个方法是具体的，它给出了一个顶级逻辑的骨架，调用一些需要子类去具体实现的步骤方法

```csharp
abstract class AbstractClass
{
	public abstract void PrimitiveOperation1(); //需要在子类中重写
	public abstract void PrimitiveOperation1();

	public void TemplateMethod()
	{
		PrimitiveOperation1()
		PrimitiveOperation2()
		SomeOtherMethod()
		...
	}
}
```

### ConcreteClass

实现父类一个或多个抽象方法。

<aside>
💡 通过调用ConcreteClass的`TemplateMethod()`这样实现了顶层逻辑一致，但是具体操作各异的可能

</aside>

# 第十一章 迪米特法则/最少知识原则

> 如果两个类不必直接通信，那这两个类就不应该发生直接的相互作用。如果其中一个需要调用另一个类的某一个方法，可以通过第三方转发
> 

在类的设计上，每一个类都应该尽量降低成员的访问权限

法则的根本思想是强调了类之间的松耦合

# 第十二章 外观模式 / Facade

> 为子系统中的一组接口提供了一个一致的界面，此模式定义了一个高层接口，这接口使得着一子系统更加容易使用
> 

可以在设计初期有意识的将**架构分层**

在子系统越来越复杂的时候，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖

### 最重要一点：

在维护系统的时候，可以创建一个发外观Facade类，来提供原有设计或遗留代码一个简单接口。让新系统和Facade对象交互，Facade与遗留代码交互所有的负责的工作。

# 第十四章 观察者模式

又叫发布-订阅模式

> 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化的时候，会通知所有观察者对象，让他们能够自动更新自己
> 

<aside>
💡 在C#主要是delegate和event的来实现Subject和Observer之间的解耦：

</aside>

普通模式下Subject需要持有多个Observer对象，并逐个通知;

利用delegate/event模式可以实现二者的解耦，实现的方式是

- Subject 中定义delegate和该delegat类型的event
- Subject中定义特定方法触发event
- 在Main（客户端）中将Observer的方法注册到Subject的event中
- 在Main中调用或Subject变动调用某方法触发event，从而进一步触发Observer的方法
- 

<aside>
💡 所以，委托对象所搭载的所有方法必须具有相同的原型和形式，也就是具有相同的参数列表和返回值类型

</aside>

# 第十五章 抽象工厂模式

其实和工厂方法模式差不多？

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%205.png)

## 15.7 用简单工厂来改进抽象工厂

把工厂类完全封装起来，从选择不同的工厂类改成某个封装类里面设置相应属性来通过对应的工厂类创建对象。从而对客户端完全透明。封装的过程类似于简单工厂类，只不过是把选择判断代码从客户端转移到了封装类之中，因此对于客户端完全解耦。

## 15.8 反射技术？改进简单工厂

可以去除简单工厂模式中的选择判断的swithc或if代码。

<aside>
💡 大概是从string转成类名？

</aside>

# 第十六章 状态模式

> 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类
> 

具体方法：

- 创建一个Context，持有一个State子类
- 创建State抽象类及具体子类。State内Handle方法用来改变Context中State类
- Context的Request方法调用State.Handle。

好处是互相持有后，可以减少不同状态过于集中的判断，可以将判断逻辑分布到不同的State子类当中

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%206.png)

# 第十七章 适配器模式 Adapter

> 将一个类的接口转换成客户希望的另一个接口。Adatper模式使得原本由于接口不兼容而不能一起工作的那些类一些工作
> 

具体方法：

1. Target接口（接口是广义的，可以是类或者狭义“接口”），其中包含目标方法Request()
2. Adaptee接口，其中包含真正实现的方法SpecialRequest()
3. 创建Adapter类，
    1. 继承至Target接口，
    2. 持有Adaptee
    3. 改写Target.Requset()， 其中调用Adaptee.SpecialRequest()方法，实现转换

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%207.png)

## 何时使用

一般是软件维护后期，双方都不容易修改的时候，可以考虑用适配器模式

<aside>
💡 类似于一个中间件？🤔

</aside>

# 第十八章 备忘录模式

> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象回复到原先保存到状态
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%208.png)

**Originator** (发起人):负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态 。Originator 可根据需要决定Memento 存储Originator 的哪些内部状态。

**Memento** (备忘录):负责存储Originator 对象的内部状态，并可防止Originator 以外的其他对象访 问备忘录Memento。备忘录有两个接口，Caretaker 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator 能够看到 一个宽接口，允许它访问返回到先前状态所需的所有数据。

**Caretaker** (管理者):负责持有备忘录Memento，不能对备忘录的内容进行操作或检查。

<aside>
💡 这当中就是把要保存的细节给封装在了Memento 中了，哪一天要更改保存的细节也不用影响客户端了

</aside>

# 第十九章 组合模式

> 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象使用具有一致性
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%209.png)

## 使用时机

需求中体现出是部分与整体的层次结构，并且希望能够忽略组合对象与单个对象的不同，统一使用组合结构中的所有对象。

<aside>
💡 后续的使用当中可以动过递归调用来实现遍历

</aside>

# 第二十章 迭代器模式

> 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2010.png)

<aside>
💡 在这个方案中，Iterator类持有Aggregate，其方法实现就是返回具体的Aggregate中的元素

</aside>

# 第二十一章 单例模式

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
最好的办法是让类自身负责保存它唯一的实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2011.png)

<aside>
💡 两点：
1 需要私有化初始化方法，避免外界直接创建实例
2 static方法来提供一个实例访问，实例不存在则在该方法中初始化一个

</aside>

# ‼️第二十二章 桥接模式

> 尽量使用合成/聚合，尽量不要使用类继承
> 

继承是一种强耦合的结构。父类变，子类就必须要变。

> 桥接模式：将抽象部分和他的实现部分分离，使他们都可以独立的变化。
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2012.png)

## 方法：

1. 创建一个抽象类
2. 创建一个抽象的实现类，并被抽象类持有
3. 抽象类的+Operation()方法其实调用抽象实现类的具体+OperationImp()
4. 以上两种类再分别子类化，实现2的持有关系，通过步骤3来实现具体实现方法的调用

## 好处：

- 抽象部分和实例部分分离
- 实现部分可以有不同的具体方式

<aside>
💡 貌似和装饰模式有点类似于纵向和横向区别

</aside>

# 第二十三章 命令模式

> 将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化：对请求排队或记录请求日志，以及支持可撤销的操作
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2013.png)

## 方法：

其实这个流程可以反过来写

1. 创建Receiver，这是具体的动作执行者
2. 创建Command接口，持有Receiver；+Execute()调用Receiver.Action来完成工作
3. 创建Invoker，持有Command序列，分别调用各个Command.Execute()来完成真正的工作
4. Client创建以上并执行

## 好处：

- 可队列化
- 计入日志
- 易于管理，例如撤销/恢复
- 最重要一点：请求和执行者对象完全解耦

<aside>
💡 貌似万物解决方法就是加一个`**indirect**`层！

</aside>

# 第二十四章 职责链模式

> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连接成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2014.png)

这种方法中，需要注意两点：

- 需要设置后继者
- 需要设置具体的处理方式

<aside>
💡 FirstRespond？

</aside>

# 第二十五章 中介者模式

尽管将一个系统分割成许多对象通常可以增加其复用性，但是对象见相互连接的激增又会降低其可复用性。大量的连接是的一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的进行任何较大的改动就十分困难了

此时必须“迪米特法则”：如果两个类不必直接通信，那么这两个类就不应该发生直接的相互作用

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2015.png)

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2016.png)

> 用一个中介者来封装一系列的对象交互。中介者使得各对象不需要显示地相互引用，从而使得其耦合松散，而且可以独立地改变他们之间的交互。
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2017.png)

## 优点

- 减少了各个Colleague的耦合，可以独立的改变和复用各个Colleague类和Mediator
- 把对象协作进行抽象。。。

## 缺点

由于CongreteMediator控制了集中化，于是就把交互的复杂性变成了中介者的复杂性

## 应用

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2018.png)

中介模式一般用于一组对象一定义良好，但是复杂的方式进行通信的场合，以及一个想定制一个分布在多个类的行为，但是又不想生成太多子类的场合

# 第二十六章 享元模式

> 运用共享技术有效地支持大量细粒度的对象
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2019.png)

## 内部状态与外部状态

享元模式能避免大量非常相似类的开销。在设计中，细粒度不同类实例的时候，大量数据基本相同，可以考虑将这些相同数据放在实例内， 但是不同的数据则通过外部传入的方式来实现，以此提高共享度减少单个实例的数目，例如：

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2020.png)

具体不同的数据：用户。通过创建用户来传入该参数实现具体的网站

# 第二十七章 解释器模式

没看得明白

# 第二十八章 访问者模式

> 表示一个作用于某对象结构中的各元素的操作。它使你可以在 不改变各元素的类前提下定义作用于这些元素的新操作
> 

![Untitled](%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%20b2e4f2be01ef40978d47311a537acb09/Untitled%2021.png)

**关键点：**

- 对操作中可能的变量进行细分。分离出Vistor和Element。
    - 例如分出**Vistor**：感情（高兴、忧伤…)，， **Element**：人类（男 or 女）这种细分是把主要特征归类，从而进行划分
    - Element类应该是**有限类**，Vistor可以**不断扩展**
- 建立一个容器类ObjectStructure，持有其中的一类 ，**Element**。提高一个高层接口可以访问它的元素。
- 对容器类里的Element迭代传入Vistor，Element.Accept(in visitor: Vistor)中调用Vistor内的方法+VisitConcreteElement()，并传入Element具体类参数。实现二者的相互关系。
- 以上都基于Visitor和Element两个抽象类实现依赖关系，实现依赖倒转原则

<aside>
💡 以上的二分，可以理解成实现 **操作** 和 **数据结构** 的分离

</aside>