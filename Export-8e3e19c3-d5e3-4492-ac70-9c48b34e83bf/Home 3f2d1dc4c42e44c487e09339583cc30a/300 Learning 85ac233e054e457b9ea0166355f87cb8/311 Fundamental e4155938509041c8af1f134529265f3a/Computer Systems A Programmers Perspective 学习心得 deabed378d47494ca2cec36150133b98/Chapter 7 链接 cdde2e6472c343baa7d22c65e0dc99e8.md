# Chapter 7 链接

## 7.2 静态链接

像 Linux LD 程序这样的静态链接器 (static linker) 以 一组可重 定位目标文件和命令行 参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

输入的可重定位目标文件由各种不同的代码和数据节 (**section)**组成，每一节都是一个连续的字节序列。

**链接器必须完成两个主要任务:**

- **符号解析 (symbol resolution) 。**目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量(即 C 语 言 中任何以 static 属性 声明的变量)。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
- **重定位 (relocation) 。**编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通
过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置 。 链接器使用汇编器产生的重定位条目 (relocation entry)的详细指令，不 加甄别地执行这样的重定位 。

> 链接器的一些基本事实:**目标文件纯粹是字节块的集合**。这些块中，有些包含程序代码有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构 。链接器将这些块连接起来，确定被连接块的运行时位 置，并且修改代码和数据块中的各种位置。
> 

## 7.3 目标文件

**目标文件（可执行文件）三种形式：**

- 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件 。
- 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行 。
- 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态加载进内存并链接。

编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文件。

Windows 使用可移植可执行 (Portable Executable, PE)格式。 

Mac os-x 使用 Mach-0 格式。

现代 x86-64 Linux 和 Unix 系统使用可执行可链接格式 (Execut­ able and Linkable Format, ELF)

## 7.4 可重定位目标文件

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled.png)

ELF 头 （ELF header) 以一个16字节的序列开始，这个序列描述了生成该文件
的系统的字的大小和字节顺序。等等……**节头部表 (section header table) 的文件偏移**。

不同节的位置和大小是由**节头部表描述**的，其中目标文件中每个节都有一个固 定大小的条目 (entry) 。

一个典型的 ELF 可重定位目标文件包含下面几个节:

- .text: 已编译程序的机器代码。
- .rodata: 只读数据
- .data: 已初始化的全局和静态 C 变量
    
    > 局部 C 变量在运行时被保存在栈中，既不出 现在 .data 节中，也不出现在 .bss 节中。
    > 
- bss: 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是 一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率:在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。
- symtab: 一个符号表，它存放在程序中定义和引用的函数和全局变的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .syrntab 中都有一张符号表(除非程序员特意用 STRIP 命令去掉它)。然而，和编译器中的符号表不同，. syrntab 符号表不包含局部变量的条目。

## 7.5 符号和符号表

每个可重定位的目标模块都有一个符号表，包含三类符合

- 模块m定义被其他模块引用的**全局符号**
- 其他定义被模块m引用的**全局符号**
- 模块m定义和引用的**局部符号**

认识到本地链接器符号和本地程序变扯不同是很重要的。 .symtab 中的符号表**不包含**对应于本地**非静态**程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类 符号不感兴趣。

定义为带有 C `static` 属性的本地过程 变量是不在栈中管理的 。 相反，编译器在 .data 或 .bss 中为每个定义分配空间 ， 并在符号表中创建一个有唯一名字的本地链接器符号。

> 🤔C语言利用 `static`属性隐蔽变量和函数名字：在C中，**源文件扮演模块的角色**。任何带有 static 属性声明的全局变量或者函数都是模块私有的。类似地，任何不带 static 属性声明的全局变量和函数都是公共的，可以被其他模块访问
> 

## 7.6 符号解析

链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的 一个确定的符号定义关联起来

> 对于C++或Java中函数重载的解决：是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一 的名字 。 这种编码过程叫做重整 (mangling), 而相反的过程叫做恢复 (demangling) 。
C++和Java采用相同的重整策略
> 
> 
> 方法被编码为原始方 法名，后面加上_，加上被重整的类名，再加上每个参数的单字母编码 。 比如， Foo: :bar(int, long)被编码为 bar_ _3Fooil。重整全局变量和模板名字的策略是相似的 。
> 

### 7.6.1 连接器如何解析多重定义的全局符号

链接器的输入是一组可重定位目标模块 。 每个模块定义一组符号，有些是局部的(只
对定义该符号的模块可见)，有些是全局的(对其他模块也可见)。如果多个模块定义同名的全局符号，会发生什么呢?下面是 Linux 编译系统采用的方法。

在编译时，编译器向汇编器输出每个全局符号，或者是强 (strong)或者是弱 (weak),
而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。

根据强弱符号的定义， Linux 链接器使用下面的规则来处理多重定义的符号名:

- 规则 1 :不允许有多个同名的强符号。
- 规则 2: 如果有一个强符号和多个弱符号同名，那么选择强符号。
- 规则 3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。

### 7.6.2 与静态库链接（0文件和a文件的关系）

所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库 (static library), 它可以用做链接器的输入。

静态库概念被提出来，以解决这些不同方法的缺点。相关的函数可以被编译为独立的
目标模块，然后封装成一个单独的静态库文件

<aside>
🤔 o + o + o + o… =  a   ☑️

</aside>

在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小 。 另一方面，应用程序员只需要包含较少的库文件的名字。

在 Linux 系统中，静态库以一种称为存档 (archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，**有一个头部用来描述每个成员目标文件的大小和位置** 。存档文件名由后缀 `.a` 标识。

<aside>
💡 各种.o文件会汇总成一个.a文件，h头文件标明这个a文件中各个o文件的大小位置
然后连接器链接的时候从.a文件中选择需要的.o文件来链接
—by myself 👍

</aside>

下面的例子里面libvector.a由addvec.o 和multvec.o 组成（篇幅省略制作过程）

```swift
linux> gcc -c main2.c
linux> gcc -statie -o prog2e main2.o ./libveetor.a
或者
linux> gcc -c main2.c
linux> gcc -statie -o prog2e main2.o -L. -lvector
```

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled%201.png)

当链接器运行时，它判定 `main2.o` 引用了 `addvec.o` 定义的 addvec 符号，所以复制 `addvec .o` 到可执行文件。因为程序不引用任何由 `multvec.o` 定义的符号，所以链接器就 不会复制这个模块到可执行文件。链接器还会复制`libc.a` 中的 printf.o 模块，以及许多C 运行时系统中的其他模块。

### 7.6.3 链接器如何使用静态库来解析引用

这一段文字进一步说明了链接时候对于[o文件和a文件区别及关系](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8.md)，a文件是一组o文件的集合，o文件是被合并成可执行文件的基本单位。a文件中没有被引用的o文件就是会被丢弃。

链接时候分别扫描链接文件的符号表，所以命令行中文件顺序有关系，**一般被调用的库文件放在最后。**

## 7.7 重定位

一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义 (即它的一个输入目标模块中的一个符号表条目)关联起来。此时，链接器就知道它的输入 目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤 中，**将合并输入模块，并为每个符号分配运行时地址**。

重定位由两步组成:

- 重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。
- 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的 引用，使得它们指向正确的运行时地址。

## 7.8 可执行目标文件

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled%202.png)

<aside>
🤔 有个说法：ELF文件的两个视角
从磁盘的ELF文件来看，是section，也就是节
从加载到内存的角度来看是segement，称为段，是把多个类似的节合并在一起连续存储到内存中

</aside>

**可执行目标文件的格式类似可重定位目标文件的格式 。都是o文件**

ELF 头描述文件的总体格 它还包括程序的入口点 (entry point ) , 也就是当程 序 运行 时要 执 行 的第一条指令的地 址 。

 .text、 .rodata 和 .data 节与可重定位目标文件中的节 是 相似的，除了这些节巳经被 重定位到它们最终的运行时内存地址以外。

.init节定义了一个小函数，叫做.init程序式的初始化代码会调用它 。

## 7.9 加载可执行目标文件

可执行目标文件不是内置的shell命令，需要通过加载器（loader）来运行它。

任何Linux程序都可以通过execve函数来调用加载器，加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做**加载**。

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled%203.png)

### 加载实际是如何工作的一个概述:

Linux 系统 中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当 shell 运行一个 程序时，父 shell 进程生成一个子进程，它是父进程的一个复制。子进程通过 execve 系统调用启动加载器。加栽器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零 。 通过将虚拟地址空间中的页映射到可执行文件的页大小的片 (chunk), 新的代码和数据段袚初始化为可执行文件的内容。最后， 加载器跳转到 _start地址，它最终会调用应用程序的 main函数。除了一些头部息，在 加栽过程中没有任何从磁盘到内存的数据复制 。 直到 CPU 引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。

## 7.10 动态链接共享库

> **静态库仍然有一些明显的缺点。
静态库和所有的软件一样，需要定期维护和更新。**如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。
另一个问题是几乎每个 C 程序都使用标准 I/0 函数，比如 printf 和 scanf。在运行时，**这些函数的代码会被复制到每个运行进程的文本段中** 。 在一个运行上百个进程的典型 系统上，这将是对稀缺的内存系统资源的极大浪费。
> 

**共享库 (shared Iibrary)**是致力千解决静态库缺陷的一个现代创新产物。共享库是一个 目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来 。这个过程称为动态链接 (dynamic linking) , 是由一个叫做动态链接器 (dynamic linker) 的程序来执行的 。

共享库也称为共享目标 (shared object), 在 Linux 系统中通常用 .so后缀
来表示。微软的操作系统大最地使用了共享库，它们称为 DLLC动态链接库)。

命令和前面的静态变异类似，参数有差异

```bash
linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c //生成动态库
linux> gcc -o prog21 main2.c ./libvector.so //链接
```

这样就创建了一个可执行目标文件 prog21, 而此文件的形式使得它在运行时可以和 `libvector.so` 链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程 序加载时，动态完成链接过程。认识到这一点是很重要的此时，没有任何让 bvector. so 的代码和数据节真的被复制到可执行文件 prog21 中。反之，链接器复制了一些重定位和 符号表信息，它们使得运行时可以解析对 `libvector.so` 中代码和数据的引用。

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled%204.png)

### 加载过程

当加载器加载和运行可执行文件 prog21 时，它注意到 prog21 包含一个 `.interp` 节，这一节包含动态 链接器的路径名。然后加载它！！！在执行下面的重定位完成链接

- 重定位 libc.so 的文本和数据到某个内存段。
- 重定位 libvector.so 的文本和数据到另一个内存段 。
- 重定位 prog21 中所有对由 libc.so 和 libvector.so 定义的符号的引用。
- 最后，动态链接器将控制传递给应用程序。

## 7.11 从应用程序中加载和链接共享库

应用程序还可能在它运行时要求动态链接器加载和链接某个共享 库，而无需在编译时将那些库链接到应用中。

Linux 系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接 共享库。

```c
#include <dlfcn.h>
void *dlopen(const char *filename, int flag);
//还有一系列和动态链接相关的函数
```

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled%205.png)

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled%206.png)

## 7.13 打桩机制

Linux 链接器支持一个很强大的技术，称为库打桩 (library interpositioning), 它允许你**截获对共享库函数的调用，取而代之执行自己的代码。**使用打桩机制，你可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全不同的实现。

下面是它的基本思想:给定一个需要打桩的目标函数，创建一个包装函数，它的原型与标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。

打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。

## 7. 14 处理目标文件的工具

在 Linux 系统中 有大最可用的工具 可以 帮助你理解和处理目 标文件 。特别 地， GNUbinutils 包尤其有帮助，而且可以运行在每个 Linux 平 台上 。

- AR: 创建静态库，插入、删除、列出和提取成员 。
- STRINGS: 列出 一 个目标文件中所有可打印的字符串。
- STRIP: 从 目标文件 中删 除符号表信息 。
- NM: 列出一个目标文件的符号表中定义的符号。
- SIZE: 列出目标文件中节的名字和大小 。
- READELF: 显示 一 个目标文件的完整结构，包括 ELF 头中编码的所有信息。包含SIZE 和 NM 的 功能。
- OBJDUMP: 所有 二 进制 工 具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 节中的 二 进制指令 。

Linux 系统为操作共享库还提供了 LDD 程序:

- LDD: 列出一 个可执 行文 件在运行 时所 需要的共享库 。

## 小结

链接可以在编译时由静态编译器来完成 ，也可以在加载时和运行时由动态链接器来完成。

- 链接器处理称为目标文件的二进制文件，它有 3 种不同的形式:**可重定位**的、**可执行**的和**共享的**。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到内存中并执行。 共享目标文件(共享库)是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用 dlopen库的函数时。
- 链接器的两个主要任务是**符号解析**和**重定位** ， 符号解析将目标文件中的每个全局符号都绑定到一个唯一的 定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。

静态链接器是由像 GCC这样的编译驱动程序调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引 入微妙的错误 。

多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用 。 许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起令人迷惑的链接时错误的来源 。

**加载器**将可执行文件的内容映射到内存，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的例程和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。
被编译为位置**无关代码**的共享库可以加载到任何地方，也可以在运行时被多个进程享。为了加载、 链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。