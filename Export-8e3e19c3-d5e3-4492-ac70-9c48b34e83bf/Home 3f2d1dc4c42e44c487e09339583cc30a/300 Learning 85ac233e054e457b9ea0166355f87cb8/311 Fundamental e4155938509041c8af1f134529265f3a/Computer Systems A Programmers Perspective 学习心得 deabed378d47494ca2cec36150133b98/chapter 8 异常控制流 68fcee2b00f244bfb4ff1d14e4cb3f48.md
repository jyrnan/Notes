# chapter 8 异常控制流

现代系统通过使控制流发生突变来对这 些情况 做出反应 。一般而言 ，我们把这些突变 称为异常控制流 (Exceptional Control Flow, ECF)

- 理解 ECF 将帮助你理解并发。
- 理解 ECF 将帮助你理解软件异常如何工作

## 8.1 异常

异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现

异常 (exception)就是控制流中的突变，用来响应处理器状态中的某些变化。

### 8.1.1 异常处理

在运行时(当系统在执行某个程序时)，处 **二** 异常处理程序2的代码理器检测到发生了一个事件，并且确定了相应的异常号 k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k, 转到相应的处理程序。

![Untitled](chapter%208%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%2068fcee2b00f244bfb4ff1d14e4cb3f48/Untitled.png)

异常号是到异常表中的索引，异常 表 的起始地址放在一个叫做异常表基址寄存器 (exception table base register)的特殊 CPU 寄存器里。

### 8.1.2 异常的类别

异常可以分为四类:中断 (interrupt) 、陷阱 (trap) 、故障 Cfault)和终止 (abort) 。
图 8-4 中的表对这些类别的属性做了小结 。

![Untitled](chapter%208%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%2068fcee2b00f244bfb4ff1d14e4cb3f48/Untitled%201.png)

**陷阱** 最重要 的用途是在用户程序和内核之间提供一个像过程一 样的接口， 叫做系统调用 。从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不 同。普通的函数运行在**用户模式**中，用户模式限制了函数可以执行的指令的类型，而且它们 只能访问与调用函数相同的栈。系统调用运行在**内核模式**中，内核模式允许系统调用执行特 权指令，并访问定义在内核中的栈 。

## 8.2 进程

进程的经典定义就是一个执行中程序的实例。

系统中的每个程序都运行在某个进程的上下文 (context) 中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及 打开文件描述符的集合 。

**进程提供给应用程序的关键抽象:**

- 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。
- 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。

### 8.2.1 逻辑控制流

系列的程序计数器 (PC) 的值，这些值唯 一 地对应于包含 在程序的可执行目标文件中的指令，或 是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值的序列叫做**逻辑控制流**，或者简称逻辑流。

关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然 后被抢占(preempted)(暂时挂起)，然后轮到其他进程

### 8.2.2 并发流

一个逻辑流的执行在时间上与另一个流重叠，称为并发流 (concurrent flow) , 这两个 流被称为并发地运行。

多个流并发地执行的一般现象被称为并发 (concurrency) 。 一 个进程和其他进程轮流运 行的概念称为多任务 (multitasking) 。 一个进程执行它的控制流的一部分的每一时间段叫 做时间片 (time slice) 。因此，多任务也叫做时间分片 (time slicing) 。

如果两个流 并发 地运行在不同的处 理器核或者计算机上，那么我们称它们为并行流 (parallel flow) ,

<aside>
💡 并发是同一个时间段内分别运行，并行是分别在不同处理器上同时运行？

</aside>

### 8.2.3 私有地址空间

尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都
有相同的通用结构。比如，图 8-13 展示了一个 x86-64 Linux 进程的地址空间的组织结构。

![Untitled](chapter%208%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%2068fcee2b00f244bfb4ff1d14e4cb3f48/Untitled%202.png)

### 8.2.4 用户模式和内核模式

为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制 一 个应用可以执行的指令以及它可以访问的地址空间范围。
处理器通常是用某个控制寄存器中的一个模式位 (mode bit)来提供这种功能的，该寄 存器描述了进程当前享有的特权。

当设置了模式位时，进程就运行在**内核模式**中(有时叫 做超级用户模式)。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以 访问系统中的任何内存位置。

没有设置模式位时，进程就运行在**用户模式**中。用户模式中的进程不允许执行特权指令 (privileged instruction), 比如停止处理器、改变模式位，或者发起一个 I/0 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，**用户程序必须通过系统调用接口间接地访问内核代码和数据。**
运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的 唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递 到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中， 当它返回到应用程序代码时，处理器就把模式从内核摸式改回到用户模式。

### 8.2.5 上下文切换

内核为每个进程维持 一 个**上下文 (context)** 。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做**调度 (scheduling),** 是由内核中称为**调度器 (scheduler)** 的代码处理的。

## 8.4 进程控制

### 8.4.2 创建和终止进程

进程的三种状态

- **运行**
- **停止** 进程的执行被挂起 (suspended), 且不会被调度。
- **终止** 进程会因为三种原因终止:
    - 1)收到一个信号，该信 号 的 默认行为是终止进程，
    - 2)从主程序返回，
    - 3)调用 exit 函数。exit 函数以 status 退出状态来终止进程(另一种设置退出状态的方法是从主程 序 中 返回一个整数值)。`void exit(int status);`

父进程通过调用 fork 函数创 建 一个新的运行的子进程 。`pid_t fork(void);`

新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相 同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父 进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fo:rk时，子进程可以读写父 进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在千它们有不同的 PID。

![Untitled](chapter%208%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%2068fcee2b00f244bfb4ff1d14e4cb3f48/Untitled%203.png)

进程图特别有助千理解带有嵌套 fork 调用的程序。例如，图 8-17 中的程序源码中两 次调用了 fork。对应的进程图可帮助我们看清这个程序运行了四个进程，每个都调用了 一次 printf, 这些 printf 可以以任意顺序执行。

<aside>
💡 Fork是创建一个和现在一样的进程。所以会创建两次，共产生4个。这里涉及到操作系统的知识

</aside>

### 8.4.3 回收子进程

如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父。 init 进程 的 PID 为 1, 是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进 程没有回收它的僵死子进程就终止了，那么内核会安排 init 进程去回收它们。

### 8.4.4 让进程休眠

`unsigned int sleep(unsigned int secs);`sleep 函数将一个进程挂起一段指定的时间。

另一个很有用的函数是 pause 函数，该函数让调用函数休眠，直到该进程 收到一个信号 。`int pause(void);`

### 8.4.5 加载并运行程序

execve 函数在当前进程的上下文中加载并运行一个新程序。

`int execve(const char *filename, const char *argv[], const char *envp[]);`

execve 函数加载并运行可执行目标文件 filename, 且带参数列表 argv 和环境变量 列表 envp。只有当出现错误时，例如找不到 filename, execve 才会返回到调用程序。 所以，与 fork 一次调用返回两次不同， execve 调用一次并从不返回。

> 按照惯例， argv [0] 是可执行目标文件的名字。
> 

在 execve 加载了filename 之后 ，它调用 7. 9 节中描述的启动代码。启动代码设置 栈，并将控制传递给新程序的**主函数**，该主函数有如下形式的原型

`int main(int argc, char **argv, char **envp);` 

> main函数有 3个参数: 1)argc, 它给出 argv[ ]数组中非空指针的数量， 2)argv, 指向 argv[ ]数组中的第一个条目， 3)envp, 指向 envp[] 数组中的第一个条目。
> 

或者等价于`int main(int argc, char *argv[], char *envp[]) ;`

当 main 开始执行时，用户栈的组织结构如图 8-22 所示。让我们从栈底(高地址)往栈顶 (低地址)依次看一看。首先是参数和环境字符串。栈往上紧随其后的是以 null 结尾的指针 数组，其中每个指针都指向栈中的一个环境变量字符串。全局变最 environ 指向这些指 针中的第一个 envp[0]。紧随环境变量数组之后的是以 null 结尾的 argv[)]数组，其中每个元素都指向栈中的一个参数字符串。在栈的顶部是系统启动函数 libc_start_main(见 7.9 节)的栈帧。

![Untitled](chapter%208%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%2068fcee2b00f244bfb4ff1d14e4cb3f48/Untitled%204.png)

> **程序与进程** 
这是一个适当的地方，停下来，确认一下你理解了程序和进程之间的区别。程序是
一堆代码和数据;程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间 中。**进程是执行中程序的一个具体的实例**;程序总是运行在某个进程的上下中。
如果你想要理解 fork 和 execve 函数，理解这个差异是很重要的 。 
fork 函数在新的子进程 中运行相同的程序，新的子进程是父进程的一个复制品 。 
execve 函数在当前进程的上下文中加栽并运行一个新的程序 。 它会覆盖当前进程的地址空间，但并没有创建一个新进程 。新的程序仍然有相同的 PID, 并且继承了调用 execve 函数时已打开的所有文件描述符 。
> 

### 8.4.6 利用fork和execve运行程序

像 Unix shell 和 Web 服务器这样的程序大量使用了 fork 和 execve 函数。shell 是一 个交互型的应用级程序，它代表用户运行其他程序。

shell 打印一个命令行提示符，等待用户 在 stdin 上输入命令行，然后对这个命令行求值。

命令行求值的代码。它的首要任务是调用 parseline 函数(见图 8-25), 这个函数解析了以空格分隔的命令行参数，并构造最终会传递给 execve 的 argv 向量。

在解析了命令行之后， eval 函数调用 builtin_comrnand 函数，该函数检查第一个命令行参数是否是一个内置的 shell 命令。

- 如果是，它就立即**解释这个命令**，并返回值 1。
- 如果 builtin—command 返回0, 那么 shell **创建一个子进程**，并在子进程中执行所请求的程序。

## 8.5 信号

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件

每种信号类型都对应千某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

### 8.5.1 信号术语

- 发送信号
- 接受信号

一个发出而没有被接收的信号叫做待处理信号 (pending signal) 。在任何时刻，一种类 型至多只会有一个待处理信号。

一 个待处理信号最多只能被接收一次

### 8.5.2 发送信号

- **进程组** 每个进程都只属千一个进程组，进程组是由一个正整数进程组 ID 来标识的 。默认地，一个子进程和它的父进程同属千一个进程组。
- **用 /bin/kill 程序发送信号** `linux> /bin/kill -9 15213`
- **从键盘发送信号**
- **用 kill 函数发送信号** `int kill(pid_t pid, int sig);`
- **用 alarm函数发送信号** alarm 函数安排内核在 secs 秒后发送一个 SIGALRM 信号给调用进程

### 8.5.3 接收信号

每 个信号类型都有 一 个预定义的默认行为，是下面中的一种:

- 进程终止。
- 进程终止并转储内存。
- 进程停止(挂起)直到被 SIGCONT 信号重启。
- 进程忽略该信号。

<aside>
💡 中间略过部分内容，实在看不懂😂

</aside>

## 8.6 非本地跳转

C 语言提供了一种用户级异常控制流形式，称为非本地跳转 (nonlocal jump), 它将控 制直接从 一 个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列

非本地跳转是通过 setjrnp 和 longjrnp 函数来提供的 。