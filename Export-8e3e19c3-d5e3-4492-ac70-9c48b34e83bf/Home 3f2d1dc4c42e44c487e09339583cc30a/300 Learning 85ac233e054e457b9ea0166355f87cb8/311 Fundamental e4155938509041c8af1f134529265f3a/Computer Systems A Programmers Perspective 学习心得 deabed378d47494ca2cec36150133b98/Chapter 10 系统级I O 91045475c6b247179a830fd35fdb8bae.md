# Chapter 10 系统级I/O

## 10.1 Unix I / O

所有的 I/0 设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当 作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引 出一个简单、低级的应用接口，称为 Unix I/ 0, 这使得所有的输入和输出都能以一种统 一且一致的方式来执行:

- 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访间一个 1/0 设备。内核返回一个小的非负整数，叫做**描述符**，它在后续对此文件的所有操 作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这 个描述符。
- Linux shell 创建的每个进程开始时都有三个打开的文件:
    - 标准输入(描述符为 0)
    - 标准输出(描述符为 1)
    - 标准错误(描述符为 2)
- 改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置 k, 初始为 0。这个文件位置是从文件开头起始的**字节偏移量**。应用程序能够通过执行 seek 操 作，显式地设置文件的当前位置为 K。
- 读写文件。一个读操作就是从文件复制 n>O 个字节到内存。给定一个大小为 m 字节的文件，当 k~m 时执行读操作 会触发一个称为 `end-of-file(EOF)` 的条件，应用程序能检测到这个条件。在文件结 尾处并没有明确的 "EOF 符号” 。
类似地，写操作就是从内存复制 n>O 个字节到一个文件，从当前文件位置 k开始，然后更新 k。
- 关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。

## 10.2 文件

Linux的文件类型

- **普通文件** 应用程序常常要区分文本文件 (text file)和二 进制文件 (binary file) , 文本文件是只含有 ASCII 或 Unicode 字符的普通文件;二 进制文件是所有其他的文件。对内核而言，文本文件和二进制文件没有区别。
- **目录**是包含一组链接 （link) 的文件，其中每个链接都将一个文件名 (filename)映射到一个文件，这个文件可能是另一 个目录
    
    <aside>
    💡 目录也是文件！！！原来 #Notion 页面的组织方式其实就是彻底贯彻了Unix的一切皆文件的思想：目录不过也是包含一组链接的文件。
    
    </aside>
    
- **套接字**是用来与另一个进程进行跨网络通信的文件
- 其他文件类型包含命名通道 (named pipe) 、符号链接 (symbolic link), 以及字符和块设备 (character and block device)

## 10.4 读和写文件

应用程序是通过分别调用read和write函数来执行输入和输出的

## 10.6 读取文件元数据

应用程序能够通过调用stat和fstat的函数检索到关于文件的信息（文件元数据（metadata））

```c
#include <unistd.h>
#include <sys/stat.h>

int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
```

## 10.7 读取目录内容

### readdir

应用程序可用`readdir`系列函数来读取目录的内容

```c
#include <sys/types.h>
#include <dirent.h>

DIR *opendir(const char *name);
```

### opendir

函数`opendir`以路径名为参数，返回指向目录流（directory stream）的指针。流是对条目有序列表的抽象，这里指的是目录项的列表

```c
#include <dirent.h>

struct dirent *readdir(DIR *dirp); //返回若成功则指向下一个目录项的指针，出错则为NULL

//
struct dirent {
	ino_t d_ino; //inode number 文件位置
	char d_name[256]; //Filename 文件名
```

### closedir

关闭文件夹

```c
#include <dirent.h>

int closedir(DIR *dirp);
```

## 10.8 共享文件

Linux内核用三个相关的数据结构来表示打开的文件：

- 描述符表(descriptor table)每个进程都有它独立的描述符表，它的表项是由进程 打开的文件描述符来索引的 。 每个打开的描述符表项指向文件表中的一个表项。
- 文件表 (file table) 。打开文件的集合是由一张文件表来表示的，所有的进程共享这 张表。每个文件表的表项组成(针对我们的目的)包括当前的文件位置、引用计数 (reference count) (即当前指向该表项的描述符表项数)，以及一个指向 v-node 表中 对应表项的指针 。 关闭一个描述符会减少相应的文件表表项中的引用计数。内核不 会删除这个文件表表项，直到它的引用计数为零。
- v-node 表 (v-node table) 。 同文件表一样，所有的进程共享这张 v-node 表 。 每个表 项包含 s七at 结构中的大多数信息，包括 st_mode 和 st_size 成员。

![Untitled](Chapter%2010%20%E7%B3%BB%E7%BB%9F%E7%BA%A7I%20O%2091045475c6b247179a830fd35fdb8bae/Untitled.png)

## 10.9 I / O重定向

I / O重定向是如何工作的呢?一种方式是使用 dup2 函数。

`int dup2(int oldfd, int newfd);`

<aside>
💡 事实上就是复制描述符表表项覆盖旧的描述符表表项

</aside>

![Untitled](Chapter%2010%20%E7%B3%BB%E7%BB%9F%E7%BA%A7I%20O%2091045475c6b247179a830fd35fdb8bae/Untitled%201.png)

## 10.10 标准I / O

C 语言定义了一组高级输入输出函数，称为标准 1/0 库，为程序员提供了 Unix I/0 的较高级别的替代。这个库 (libc)提供了打开和关闭文件的函数 (fopen 和 fclose) 、读 和写字节的函数 (fread 和 fwrite) 、读和写字符串的函数 (fgets 和 fputs), 以及复杂 的格式化的 I/0 函数 (scanf 和 printf) 。

标准 I/0 库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指
向 FILE 类型的结构的指针。每个 ANSI C 程序开始时都有三个打开的流 stdin、 和 stderr, 分别对应于标准输入、标准输出和标准错误:

```c
#include <stdio.h>
extern FILE *stdin; /* Standard input (descriptor 0) */
extern FILE *stdout; /* Standard output (descriptor 1) */
extern FILE *stderr; /* Standard error (descriptor 2) */
```

类型为 FILE 的流是对文件描述符和流缓冲区的抽象 。 流缓冲区的目的和 RIO 读缓冲 区的一样:就是使开销较高的 Linux 1/0 系统调用的数量尽可能得小。

## 10.11 综合：我们该使用哪像I / O函数

![Untitled](Chapter%2010%20%E7%B3%BB%E7%BB%9F%E7%BA%A7I%20O%2091045475c6b247179a830fd35fdb8bae/Untitled%202.png)

一些基本的指导原则 :

• Gl : 只要有可能就使用标准 I/0。
• G2: 不要使用 scanf 或 rio_readlineb 来读二进制文件 。 
• G3 : 对网络套接字的 I/0 使用 RIO 函数 。

## 10.12 小结

Linux 提供了少星的基于 Unix 1/0 模型的系统级函数，它们允许应用程序打开、关闭、读和写文件， 提取文件的元数据，以及执行 l/0 重定向 。 Linux 的读和写操作会出现不足值，应用程序必须能正确地 预计和处理这种情况。应用程序不应直接调用 Unix l/0 函数，而应该使用 RIO 包， RIO 包通过反复执行 读写操作，直到传送完所有的请求数据，自动处理不足值。

Linux 内核使用 三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件 表 中的表 项，而打开文件表中的表项又指向 v-node 表中的表项。每个进程都有它自己单独的描述符表，而所有的 进程共享同一个打开文件表和 v-node 表。理解 这些结构的 一般组成就能 使我们清楚地理解文件共享和 l/0重定向。

标准 l/0 库是基千 Unix l/0 实现的，并提供了一组强大的高级 I/0 例程。对于大多数应用程序而 言，标准 I/0 更简单，是优千 Unix I/0 的选择。然而，因为对标准 1/0 和网络文件的一些相互不兼容的 限制， UnixI/0比之标准l/0更该适用于网络应用程序。