# Chapter 11 网络编程

## 11.1 客户端-服务器编程模型

认识到客户端和服务器是进程，而不是常提到的机器或者主机，这是很重要的。

## 11.2 网络

对主机而言，网络只是又一种 I/0 设备，是数据源和数据接收方

### hub

一个以太网段 (Ethernet segment)包括一些电缆(通常是双绞线)和一个叫做集线器的 小盒子（Hub？）

### 交换机

使用一些电缆和叫做网桥 (bridge)的小盒子，多个以太网段可以连接成较大的局域网， 称为桥接以太网 (bridged Ethernet),网桥比集线器更充分地利用了电缆带宽。利用一种聪明的分配算法，它们随着时间自 动学习哪个主机可以通过哪个端口可达，然后只在有必要时，有选择地将帧从一个端口复 制到另一个端口。

### 路由器

在层次的更高级别中，多个不兼容的局域网可以通过叫做路由器 (router) 的特殊计算 机连接起来，组成一个 internet(互联网络)

<aside>
💡 联网络思想的精髓，封装是关键。

</aside>

## 11.3 全球IP因特网

因特网的客户端和服务器混合使用套接宇接口函数和 Unix 1/0 函数来进行通信(我们 将在 11. 4 节中介绍套接字接口)。通常将**套接字**函数实现为系统调用，这些系统调用会陷 入内核，并调用各种内核模式的 TCP/IP 函数。

### TCP/IP

实际是一个协议族，其中每一个都提供不同的功能。例如， IP 协议提供基本 的命名方法和递送机制，这种递送机制能够从一台因特网主机往其他主机发送包，也叫做 数据报 (datagram) 。 IP 机制从某种意义上而 言 是不可靠的，因为，如果数据报在网络中丢 失或者重复，它并不会试图恢复。 UDP(Unreliable Datagram Protocol, 不可靠数据报协 议)稍微扩展了 IP 协议，这样一来，包可以在进程间而不是在主机间传送。 TCP 是 一 个构 建在 IP 之上的复杂协议，提供了进程间可靠的全双工(双向的)连接。为了简化讨论，我 们将 TCP/IP 看做是一个单独的整体协议。

### 11.3.1 IP地址

一个 IP 地址就是一个 32 位无符号整数。网络程序将 IP 地址存放在如图 11-9 所示的IP 地址结构中。

IP地址是一个32位整数，但是很不幸被放入了一个struct 中

```c
/* IP address structure */
struct in_addr {
	uint32_t s_addr; /* Address in network byte order(big-endian) */
}
```

IP地址结构中总是以大端法的顺序来存放，一下函数可以实现网络和主机字节顺序间转换

```c
#inclue <arpa/inet.h>

uint32_t htonl(uint32_t hostlong) //主机->网络
uint32_t ntohl(uint32_t netlong); //网络->主机
//没有对应64位的，有16位的
```

### 获取IP地址

通过hostname命令来获取本机ip地址

```c
linux> hostname -i
128.2.210.175
```

### 实现ip地址和十进制串之间转换

```c
#
```

### 11.3.3 因特网连接

因特网客户端和服务器通过在连接上发送和接收字节流来通信。从连接一对进程的意 义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是全双工的。

一个套接宇是连接的一个端点。每个套接字都有相应的套接字地址，是由一个因特网 地址和一个 16 位的整数端口 e组成的，用“地址:端口”来表示。

## 11.4 套接字接口

![Untitled](Chapter%2011%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2039d0d9b12f0c4d4b9a9274a6e838b897/Untitled.png)

### 11.4.1 套接字地址结构

从 Linux 内核的角度来看， 一 个套接字就是通信的一个端点。从 Linux 程序的角度来 看，套接字就是一个有相应描述符的打开**文件**。

因特网的套接字地址存放在如图 11-13 所示的类型为 sockaddr_in 的 16 字节结构中。

![Untitled](Chapter%2011%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2039d0d9b12f0c4d4b9a9274a6e838b897/Untitled%201.png)

```c
/*
 * Socket address, internet style.
 */
struct sockaddr_in {
	__uint8_t       sin_len;
	sa_family_t     sin_family;
	in_port_t       sin_port;
	struct  in_addr sin_addr;
	char            sin_zero[8];
};
```

connect、bind 和 accept 函数要求一个指向与协议相关的套接字地址结构的**指针**。

### 11.4.2 socket函数

客户端和服务器使用 socket 函数来创建一个套接字描述符 (socket descriptor) 。

```c
int clientID;
clientID = socket(AF_INET, SOCK_STREAM, 0); //返回:若成功则为非负描述符，若出错则为— 1。
```

### 11.4.3 connect函数

```c
#include <sys/socket.h>
connect(int, const struct sockaddr *, socklen_t)
```

### 11.4.4 bind函数

```c
#inclued <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

### 11.4.5 listen函数

```c
	int listen(int sockfd, int backlog);
```

### 11.4.6 accept函数

```c
int accept(int listend, struct sockaddr *addr, int artlen>;
```

监听描述符和已连接描述符之间的区别使很多人感到迷惑。监听描述符是作为客户端 连接请求的一个端点。它通常被创建一次，并存在千服务器的整个生命周期。已连接描述 符是客户端和服务器之间已经建立起来了的连接的一个端点。

### 11.4.8 套接字的辅助函数

- open_clientfd
- open_listenf

## 11.5 Web服务器

### 11.5.2 Web内容

对于 Web 客户端和服务器而言，内容是与一个 `MIME (Multipurpose Internet Mail
Extensions`, 多用途的网际邮件扩充协议)类型相关的字节序列

![Untitled](Chapter%2011%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2039d0d9b12f0c4d4b9a9274a6e838b897/Untitled%202.png)

### Web 服务器以两种不同的方式向客户端提供内容:

- 取 一 个磁盘文件，并将它的内容返回给客户端 。磁 盘文件称为静态内容 (static content) , 而返回文件给客户端的过程称为服务静态内容 (serving static content)。.
- 运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为动态内容 (dynamic content) , 而运行程序 并返 回它的输出到客户端的过程称为服务动态内容(servingdynamiccontent)。

每条由 Web服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都
有一个唯 一 的名字，叫做 `URL(Universal Resource Locator`, 通用资源定位符)。

### url参数

可 执行文件的 URL 可以在文件名后包括程序参数 。"?"字符分隔文件名和参数，而且每个 参数都用"&"字符分隔开。例如， URL`http: //bluefish .ics.cs.cmu.edu:8000/cgi-bin/adder?15000&213`标识了一个叫做 /cgi- bin/adder 的可执行文件，会带两个参数字符串 15000 和 213 来调用它

> 最小的 URL后缀是"/"字符，所有服务器将其扩展为某个默认的主页，例如 /index. html。这解释了为什么简单地在浏览器中键入 一 个域名就可以取出一个网站的主 页 。 浏览器在 URL 后添 加 缺失的" /"，并将之传递给服务器，服务器又把" /"扩 展到某个默认的文件名。
> 

### 11.5.4 服务动态内容

一 个称为 `CGI(Common Gateway Interface`, 通用网关接口)的实际 标准的出现解决了这些问题。

1. **客户端如何将程序参数传递给服务器**
    
    GET 请求的参数在 URI 中传递 。 正如我们看到的，一个"?"字符分隔了文件名和参 数，而每个参数都用 一 个"&"字符分隔开 。 
    参数中不允许有空格，而必须用字符串 "%20" 来表示。
    
2. **服务器如何将参数传递给子进程**
    
    在服务器接收 一 个如下的请求后,`GET /cgi-bin/adder?15000&213 HTTP/1.1`它调用 fork 来创建一个子进程，并调用 execve 在子进程的上下文中执行 /cgi-bin/ad­der程序 。
    像 adder 这样的程序，常常被称为 CGI 程序，因为它们遵守 CGI 标准的规则。 而且，因为许多 CGI 程序是用 Perl 脚本编 写 的，所以 CGI 程序也常被称为 CGI 脚本。在调用 execve 之前，子进程将 CGI 环境变量 `QUERY_STRING` 设置为 "15000&213", ad- der 程序在运行时可以用 Linux getenv 函数来引用它 。
    
3. **服务器如何将其他信息传递给子进程**
    
    CGI 定义了大量的其他环境变量，一个 CGI 程序在它运行时可以设置这些环境变量。 图
    
4. 子进程将它的输出发送到哪里
    
    一个 CGI 程序将它的动态内容发送到标准输出。
    
    > 在子进程加载并运行 CGI 程序之前，它使用 `Linux dup2` 函数将标准输出重定向到和客户端相关联的已连接描述符。因此，任何CGI 程序写到标准输出的东西都会直接到达客户端。
    > 
    
    ## 11.7 小结
    
    每个网络应用都是基千客户端-服务器模型的。根据这个模型， 一 个应用是由一个服务器和一个或多 个客户端组成的。服务器管理资源，以某种方式操作资源，为它的客户端提供服务。客户端-服务器模型 中的基本操作是客户端-服务器事务，它是由客户端请求和跟随其后的服务器响应组成的 。
    
    客户端和服务器通过因特网这个全球网络来通信。从程序员的观点来看，我们可以把因特网看成是一个全 球范围的主机集合，具有以下几个属性: 1)每个因特网主机都有一个唯一的 32位名字，称为它的 IP地址。 2) IP 地址的集合被映射为一个因特网域名的集合 。 3)不同因特网主机上的进程能够通过连接互相通信 。
    
    客户端和服务器通过使用套接字接口建立连接。一个套接字是连接的一个端点，连接以文件描述符的形式提供给应用程序 。套接字接 口提供了打开和关闭套接字描述符的函数 。 客户端和服务器通过读写 这些描述符来实现彼此间的通信。
    
    Web 服务 器使用 HTTP 协议和它们的客户端(例如浏览器)彼此通信 。浏览 器向服务器请求静态或者 动态的内容。对静态内容的请求是通过从服务器磁盘取得文件并把它返回给客户端来服务的。对动态内 容的请求是通过在服务器上一个子进程的上下文中运行一个程序并将它的输出返回给客户端来服务的 。 CGI 标准提供了一组规则，来管理客户端如何将程序参数传递给服务器，服务器如何将这些 参数以及其 他信息传递给子进程，以及子进程如何将它的输出发送回客户端。