# Chapter 4 处理器体系结构

一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构 (Instruction-Set Architecture, ISA)

因此， ISA 在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编 写者只需要知道允许哪些指令，以及它们是如何编码的;而处理器设计者必须建造出执行 这些指令的处理器。

### CISC & RISC

IBM 的一组硬件和编译器专家受到 IBM 研究员 John Cocke 的很大影响，认为他们 可以为更简单的指令集形式产生高效的代码。实际上，许多加到指令集中的高级指令很 难被编译器产生，所以也很少被用到。一个较为简单的指令集可以用很少的硬件实现， 能以高效的流水线结构组织起来，类似于本章后面描述的情况。直到多年以后 IBM 才 将这个理念商品化，开发出了 Power 和 PowerPC ISA。

![CISC vs RISC](Chapter%204%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%20f2e8455598ef48128b1d053e95cfb89c/Untitled.png)

CISC vs RISC

## 4.2 逻辑设计和硬件控制语言 HCL（微机原理？）

逻辑门下面是对应的 HCL 表达式: AND 用 && 表示， OR 用 11 表示，而 NOT 用!表 示。我们用这些符号而不用 C 语言中的位运算符&、 I 和~，这是因为逻辑门只对单个 位的数进行操作，而不是整个字。

![Untitled](Chapter%204%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%20f2e8455598ef48128b1d053e95cfb89c/Untitled%201.png)

![Untitled](Chapter%204%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%20f2e8455598ef48128b1d053e95cfb89c/Untitled%202.png)

### 4.2.3 字级的组合电路和 HCL 整数表达式

通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常，我 们设计能对数据宇 (word)进行操作的电路

执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位

![Untitled](Chapter%204%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%20f2e8455598ef48128b1d053e95cfb89c/Untitled%203.png)

算术 /逻辑单元 (ALU)是一种很重要的组合电路，图 4-15 是它的 一 个抽象的图示

![Untitled](Chapter%204%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%20f2e8455598ef48128b1d053e95cfb89c/Untitled%204.png)

### 4.2.5 存储器和时钟

组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等 千输入的某个函数的输出。为了产生时序电路(sequentialc订cuit), 也就是有状态并且在这个 状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制 的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。

### 两类存储器设备:

- 时钟寄存器(简称寄存器)存储单个位或字。时钟信号控制寄存器加载输入值。
- 随机访问存储器(简称内存)存储多个字，用地址来选择该读或该写哪个字。随机访
问存储器的例子包括:
    - 1)处理器的虚拟内存系统，硬件和操作系统软件结合起来使
    处理器可以在一个很大的地址空间内访问任意的字;
    - 2)寄存器文件，在此，寄存器标识符作为地址。在 IA32 或 Y86-64 处理器中，寄存器文件有 15 个程序寄存器(%rax~%r14) 。

> 虽然寄存器文件不是组合电路，因为它有内部存储。不过，在我们的实现中，从寄存 器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。
> 

## 4.3 Y86-64的顺序实现 （一种CPU指令实现范例？）

- **取指 (fetch)** : 取指阶段从内存读取指令字节，地址为程序计数器 (PC) 的值。从指
令中抽取出指令指示符字节的两个四位部分，称为 icode(指令代码)和辽un(指令
功能)。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符
rA 和 rB。它还可能取出一个四字节常数字 vale。它按顺序方式计算当前指令的下
一条指令的地址 valP。也就是说， valP 等于 PC 的值加上已取出指令的长度。
- b: 译码阶段从寄存器文件读入最多两个操作数，得到值 valA 和/或 valB,
通常，它读入指令 rA 和 rB 字段指明的寄存器，不过有些指令是读寄存器 %rsp 的。
- **执行 (execute)**: 在执行阶段，算术/逻辑单元 (ALU) 要么执行指令指明的操作(根
据江un的值)，计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们
称为 valE。在此，也可能设置条件码。对一条条件传送指令来说，这个阶段会检
验条件码和传送条件(由 ifun 给出)，如果条件成立，则更新目标寄存器。同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支。
- **访存 (memory):** 访存阶段可以将数据写入内存，或者从内存 读出数据。读出的值
为 valM。
- **写回 (write back) :** 写回阶段最多可以写两个结果到寄存器文件。
- **更新 PC（PC update):** 将 PC 设置成下一条指令的地址。

我们面临的一个挑战是将每条不同指令所需要的计算放入到上述那个通用框架中。

可以参考下图看看不同命令都被分解成相应都阶段

![Untitled](Chapter%204%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%20f2e8455598ef48128b1d053e95cfb89c/Untitled%205.png)

### 4.3.2 SEQ硬件结构

![Untitled](Chapter%204%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%20f2e8455598ef48128b1d053e95cfb89c/Untitled%206.png)

SEQ 的实现包括**组合逻辑**和**两种存储器设备**:时钟寄存器(程序计数器和条件码寄存 器)，随机访问存储器(寄存器文件、指令内存和数据内存)

- 组合逻辑不需要任何时序或 控制 只要输入变化了，值就通过逻辑门网络传播。
- 四个硬件单元需要对它们的时序进行明确的控制 程序计数器、条件码寄 存器、数据内存和寄存器文件。这些单元通过一个时钟信号来控制，它触发将新值装载到 寄存器以及将值写到随机访间存储器。

> **SEQ小结**现在我们已经浏览了 Y86-64 处理器的一个完整的设计。可以看到，通过将执行每条不同指令所需的步骤组织成一个统一的流程，就可以用很少晕的各种硬件单元以及一个时钟来控制计算的顺序，从而 实 现整个处理器。
> 

## 4. 4 流水线的通用原理

SEQ这种实现方法不能充分利用硬件单元，因为每个单元只在整个时钟周期的一部分时间
内才被使用 。 我们会看到引入流水线能获得更好的性能。

![Untitled](Chapter%204%20%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%20f2e8455598ef48128b1d053e95cfb89c/Untitled%207.png)

> 为了提高时钟频率，现代处理器采用了很深的 (15 或更多的阶段)流水线。处理器架构师 将指令的执行划分成很多非常简单的步骤，这样 一 来每个阶段的延迟就很小。电路设计者小 心地设计流水线寄存器，使其延迟尽可能得小。芯片设计者也必须小心地设计时钟传播网 络，以保证时钟在整个芯片上同时改变。所有这些都是设计高速微处理器面临的挑战。
> 

### 4.5.4 预测下一个PC（省略……）

这些流水线化的设计的吞吐量都限制在最多一个时钟周期一条指令。

### 当前微处理器设计

> 最近，随着多核处理器受到追捧，有些人声称通过在一个芯片上集成许多简单的处
理器，比使用少量更复杂的处理器能荻得更多的整体计算能力 。 这种策略有时被称为 “多核”处理器 [10] 。
> 

## 4.6 小结

- 我们已经看到，指令集体系结构，即 ISA, 在处理器行为(就指令集合及其编码而言)和如何实现处 理器之间提供了一层抽象 。
- ISA 提供了 程序执行的一种顺序说明，也就 是一条指令执行完了，下 一 条指 令才会开始 。
- ISA 既有 RISC 指令集的属性，也有 CISC 指令集的属性。然后，将不同指令组织放到五个阶段中处理， 在此，根据被执行的指令的不同，每个阶段中的操作也不相同 。
- 流水线化通过让不同的阶段并行操作，改进了系统的吞吐抵性能。