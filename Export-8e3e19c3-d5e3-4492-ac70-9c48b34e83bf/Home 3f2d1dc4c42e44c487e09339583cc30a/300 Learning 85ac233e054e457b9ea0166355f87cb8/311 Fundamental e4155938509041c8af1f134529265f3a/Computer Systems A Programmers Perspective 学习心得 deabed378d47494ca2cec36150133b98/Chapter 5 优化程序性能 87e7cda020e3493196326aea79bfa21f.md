# Chapter 5 优化程序性能

### 优化的方式

- 合适的算法和数据结构
- 高效编译执行的源代码
- 分拆任务，实现并行计算

## 5.4 消除循环的低效率

Code motion 代码移动：

这类优化包括识别要执行多次（例如循环）但是计算结果不会改变的计算

例如设定for循环的边界，如果每次都计算这个边界，就可以将这个边界计算过程移到前面设定一个变量，再for循环中调用

```c
for (i = 0; i <= strlen(s); i++) {...}

//改成下面
long len = strlen(s);
for (i = 0; i <= len; i++ {...}
```

## 5.6 消除不必要的内存引用

在循环中引入局部变量。这样的好处是会在汇编时候产生一个本地寄存器来保存数据，不需要反复在内存和寄存器当中传输数据

```c
*dest = IDENT;
for (i = 0; i < len; i++) {
		*dest = *dest OP data[i]
}

=>
data_t acc = IDENT; //引入一个局部变量

for (i = 0; i < len; i++) {
		acc = acc OP data[i] 
}
*dest = acc;
```

## 5.8 循环展开

循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。

循环展开能够从两个方面改进程序的性能。首先，它减少了不直接 有助于程序结果的操作的数量，例如循环索引计算和条件分支。第二，它提供了一些方 法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。

例如下面，在 10行的for循环中每次处理两个数据……第二个for循环处理剩下的循环次数。

![Untitled](Chapter%205%20%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%2087e7cda020e3493196326aea79bfa21f/Untitled.png)

> 编译器可以很容易地执行循环展开。只要优化级别设置得足够高，许多编译器都能
例行公事地做到这一点。用优化等级 3 或更高等级调用 GCC, 它就会执行循环展开。
> 

## 5.9 提高并行性

### 5.9.1 多个累积变量

利用多个累积变量，可以充分利用多个功能单元流水线能力。

![Untitled](Chapter%205%20%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%2087e7cda020e3493196326aea79bfa21f/Untitled%201.png)

### 5.9.2 重新结合变换 （神奇……）

![Untitled](Chapter%205%20%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%2087e7cda020e3493196326aea79bfa21f/Untitled%202.png)

## 5.11 一些限制因素

### 5.11.1  寄存器溢出

循环并行性的好处受汇编代码描述计算的能力限制。如果我们的并行度 p 超过了可用 的寄存器数量，那么编译器会诉诸溢出 (spilling), 将某些临时值存放到内存中，通常是在 运行时堆栈上分配空间。（过犹不及）所以5.8循环展开不能无限制……

## 5.12 理解内存性能

### 5.12.1 加载的性能

一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖千加载单元的延迟。

### 5.12.2 存储的性能

与加载操作 一样，在大多数情况中，存储操作能够在完全流水线化的模式中工作，每 个周期开始 一 条新的存储。

> （这部分没看懂）
> 

## 5.13 应用：性能提高技术

- 高级设计：为遇到的问题选择适当的算法和数据结构
- 基本编码原则：
    - 消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模
    
    块性以获得更大的效率 。
    
    - 消除不必要的内存引用。引入临时变量来保存中间结果 。
    只有在最后的值计算出来
    时，才将结果存放到数组或全局变量中 。
- 低级优化。结构化代码以利用硬件功能。
    - 展开循环，降低开销，并且使得进一步的优化成为可能。
    - 通过使用例如多个累积变址和重新结合等技术，找到方法提高指令级并行。
    - 用功能性的风格重写条件操作，使得编译采用条件数据传送。

## 5.15 小结