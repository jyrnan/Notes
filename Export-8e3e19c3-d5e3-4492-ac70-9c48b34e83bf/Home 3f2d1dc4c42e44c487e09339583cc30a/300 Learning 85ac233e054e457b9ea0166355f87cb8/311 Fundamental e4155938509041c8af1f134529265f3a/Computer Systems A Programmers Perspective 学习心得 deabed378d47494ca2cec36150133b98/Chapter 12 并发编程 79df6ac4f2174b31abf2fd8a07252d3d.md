# Chapter 12 并发编程

使用应用级并发的应用程序称为并发程序 (concurrent program) 。现代操作系统提供 了三种基本的构造并发程序的方法:

- **进程**。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进 程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间 通信 (interprocess communication, IPC)机制。
- **I/O 多路复用**。在这种形式的并发编程中，应用程序在**一个进程**的上下文中显式地 调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，**主程序显式地从一个状态转换到另一个状态**。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。
- **线程**。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把 线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/0 多路 复用流一样共享同一个虚拟地址空间。

## 12.1 基于进程的并发编程

构造并发程序最简单的方法就是用进程，使用那些大家都很熟悉的函数，像 fork、 exec 和 waitpid

### 12.1.2 进程的优劣

子、父进程共享文件表，但是不共享地址空间。

- 优点：独立地址空间，不会覆盖另一进程的虚拟内存
- 缺点：必须通过IPC通信，开销高。

## 12.2 基于I / O多路复用的并发编程（不太理解）

针对这种困境的一个解决办法就是 1/0 多路复用 (1/0 multiplexing)技术 。 基本的思 路就是使用 select 函数，要求内核挂起进程，只有在一个或多个 1/0 事件发生后，才将 控制返回给应用程序

## 12.3 基于线程的并发编程

线程 (thread)就是运行在进程上下文中的逻辑流。在本书里迄今为止，程序都是由每 个进程中一个线程组成的。但是现代系统也允许我们编写一个进程里同时运行多个线程的 程序。线程由内核自动调度。每个线程都有它自己的线程上下文 (thread context), 包括一 个唯一的整数线程 ID(Thread ID, TID) 、栈、栈指针、程序计数器、通用目的寄存器和 条件码。**所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。**

### 12.3.1 线程执行模型

多线程的执行模型在某些方面和多进 程的执行模型是相似的。思考图 12-12 中的 示例。每个进程开始生命周期时都是单一 线程，这个线程称为主线程 (main thread) 。

在某一时刻，主线程创建一个对等线程 (peer thread) , 从这个时间点开始，两个线 程就并发地运行。

![Untitled](Chapter%2012%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2079df6ac4f2174b31abf2fd8a07252d3d/Untitled.png)

在一些重要的方面，线程执行是不同于进程的。因为一个线程的上下文要比一个进程 的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。另一个不同就是线程 不像进程那样，不是按照严格的父子层次来组织的。和一个进程相关的线程组成一个对等 (线程)池，独立千其他线程创建的线程。主线程和其他线程的区别仅在千它总是进程中第 一个运行的线程。对等(线程)池概念的主要影响是，一个线程可以杀死它的任何对等线 程，或者等待它的任意对等线程终止。另外，每个对等线程都能读写相同的共享数据。

### 12.3.2 Posix线程

Posix 线程 (Pthreads)是在 C 程序中处理线程的一个标准接口

每个线程例程都以一个通用指针作为输入，并返回一个通用指针。如果想 传递多个参数给线程例程，那么你应该将参数放到一个结构中，并传递一个指向该结构的 指针。相似地，如果想要线程例程返回多个参数，你可以返回一个指向一个结构的指针。

### 12.3.3 创建线程

线程通过调用 p七hread_crea七e 函数来创建其他线程。

```c
#include <pthread.h>
typedef void *(func)(void *);
int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg);
```

新线程可以通过调用 pthread_self 函数来获得它自己的线程 ID。

```c
#include <pthread.h> 
pthread_t pthread_self(void);
```

### 12.3.4 终止线程

一个线程是以下列方式之一来终止的:

- 当顶层的线程例程返回时，线程会隐式地终止 。
- 通过调用 pthread—exit 函数，线程会显式地终止 。

如果主线程调用 pthread_ exit，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为thread return 。

```c
#include <pthread.h>
void pthread_exit(void *thread_return); //从不返回 。
```

- 某个对等线程调用 Linux 的 exit 函数，该函数终止进程以及所有与该进程相关的 线程 。
- 另一个对等线程通过以当前线程 ID 作为参数调用 pthread_cancel 函数来终止当 前线程。

```c
#include <pthread.h>
int pthread_cancel(pthread_t tid); //若成功则返回 o, 若出错则为非零 。
```

### 12.3.5 回收已终止线程的资源

线程通过调用 pthread_join 函数等待其他线程终止 。

pthread_join 函数会阻塞，直到线程 tid 终止，将线程例程返回的通用 (void*)指 针赋值为 thread_return 指向的位置，然后回收己终止线程占用的所有内存资源。

```c
#include <pthread.h>
int pthread_join(pthread_t tid, void **thread_return);
```

### 12.3.6 分离线程

在任何一个时间点上，线程是可结合的 (joinable)或者是分离的 (detached) 。一个可结 合的线程能够被其他线程收回和杀死 。 在被其他线程回收之前，它的内存资源(例如栈)是 不释放的。相反，一**个分离的线程是不能被其他线程回收或杀死的**。它的内存资源在它终 止时由系统自动释放。

<aside>
💡 相当于join的对立面，让自己独立

</aside>

### 12.4.2 将变量映射到内存

多线程的 C 程序中变量根据它们的存储类型被映射到虚拟内存:

- **全局变量**。全局变量是定义在函数之外的变量。在运行时，虚拟内存的读/写区域。只包含每个全局变量的一个实例，任何线程都可以引用。例如，第 5 行声明的全局变量 ptr 在虚拟内存的读 /写区域中有一个运行时实例。当一个变量只有一个实例时，我们只用变量名(在这里就是 ptr)来表示这个实例。
- **本地自动变量**。本地自动变量就是定义在函数内部但是没有 s七atic 属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例。即使多个线程执行同一个线程例程时也是如此 。 例如，有一个本地变量 tid 的实例，它保存在主线程的栈中。我们用巨 d.m 来表示这个实例 。 再来看一个例子，本地变量 my边有两个实例，一个在对等线程 0 的栈内，另一个在对等线程 1 的栈内。我们将这两个实例分别表示为 myid.pO 和 myid.pl。
- **本地静态变量**。本地静态变量是定义在函数内部并有 s七atic 属性的变量。和全局变量一样，虚拟内存的读 /写区域只包含在程序中声明的每个本地静态变量的一个实例。例如，即使示例程序中的每个对等线程都在第 25 行声明了 cnt，在运行时，虚拟内存的读 /写区域中也只有一个 cnt 的实例。每个对等线程都读和写这个实例。

## 12.6 使用线程提供并行性

题目：考 虑我们如何并行地对一列整数 o, ...， n— 1 求和。将任务分配到不同线程的最直接方法是将序列划分成 t 个不相交的区域，然后给 t 个 不同的线程每个分配一个区域。

计算求和方式：

- 最简单也最直接的选择是将线程的和放入 一个共享全局变量中，用互斥锁保护这个变量。psum-mutex 的主程序，使用多个线程将一个序列元素的和放入 一个用互斥锁保护的共享全局变量中。很慢！

> 造成性能差的原因是相对千内存更新操作的开销，同步 操作 (P 和 V)代价太大。这突显了并行编程的一项重要教训:同步开销巨大，要尽可能避 免。如果无可避免，必须要用尽可能多的有用计算弥补这个开销 。
> 
- 另一种方式：很快！

一种避免同步的方法是让每个对 等 线程在一个私有变量中计算它自 己的部分和，这个私有变量不与其他任何线程共享，

主线程(图中未显示)定义一个全局数组 psum, 每个对等线程 t 把它的部分和累积在 psum[i] 中。因为小心 地给了每个对等线程 一 个不同的内存位置来更新，所以不 需 要用互斥锁来保护这些更新。唯一需要同步的地方是主线程必须等待所有的子线程完成 。

<aside>
💡 学习到了如何使用局部变量来消除不必要的内存引用。

</aside>

> **并行程序常常被写为每个核上只运行一个线程 。**
> 

## 12.7 其它并发问题

### 12.7.1 线程安全

当用线程编 写 程序时，必须小心地编写那些具有称为线程安全性 (thread safety)属性 的函数。一个函数被称为线程安全的 (thread-safe) , 当且仅当被多个并发线程反复地调用 时，它会 一 直产 生 正确的结果。如果一个函数不是线程安全的，我们就说它是线程不安全 的 (thread-unsafe) 。

我们能够定义出四个(不相交的)线程不安全函数类:

1. 笫 1 类:不保护共享变量的函数 。 我们在图 12-16 的 thread 函数中就已经遇到了这样 的问题，该函数对一个未受保护的全局计数器变釐加 1。 将这类线程不安全函数变成线程安 全的，相对而言比较容易:利用像 P 和 V 操作这样的同步操作来保护共享的变量。这个方法 的优点是在调用程序中不需要做任何修改。 缺点是同步操作将减慢程序的执行时间 。
2. 2 类:保持跨越多个调用的状态的函数 。
3. 笫 3 类:返回指向静态变量的指针的函数。将计算结果放在一个 static 变量中，然后返回一个指向这个变量的指针。如果我 们从并发线程中调用这些函数，那么将可能发生灾难，因为正在被一个线程使用的结果会 被另一个线程悄悄地覆盖了。
4. 笫 4 类:调用线程不安全函数的函数。如果函数 f 调用线程不安全函数 g, 那么 f 就 是线程不安全的吗?不一定 。

### 12.7.2 可重入性

有一类重要的线程安全函数，叫做可重入函数 (reentrant function) , 其特点在于它们具有这样一种属性:**当它们被多个线程调用时，不会引用任何共享数据**

检查某个函数的代码并先验地断定它是可重入的，这可能吗 ? 不幸的是，不一定能这 样。如果所有的函数参数都是传值传递的(即没有指针)，并且所有的数据引用都是本地的 自动栈变 量 (即没有引用静态或 全 局变量)，那么函数就是显式可重入的 (explicitly reentrant), 也就是说，无论它是被如何调用的，都可以断言它是可重入的。

因此， Linux 系统提供大多数线程不安全函数的可重入版本 。 可重入版本的名字总是 以" r" 后缀结尾。例如， asctime 的可重入版本就叫做 asctime_r。我们建议尽可能地 使用这些函数。

### 12.7.4 竞争

当一个程序的正确性依赖千一个线程要在另一个线程到达 y 点之前到达它的控制流中的 x 点 时，就会发生竞争 (race)。

### 12.7.5 死锁

信号量引入了 一 种潜在的令人厌恶的运行时错误，叫做死锁 (deadlock), 它指的是一 组线程被阻塞了，等待一个永远也不会为真的条件

程序死锁是因为每个线程都在等 待其他线程执行一个根不可能发生的 V 操作。

> 互斥锁加锁顺序规则:给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的 。
> 

## 12.8 小结

一个并发程序是由在时间上 重叠的一组逻辑流组成的。在这一章中，我们学习三种不同的构建并 发程序的机制:进程、 I/0 多路复用和线程 。 我们以一个并发网络服务器作为贯穿全章的应用程序 。

进程是由内核自动调度的，而且因为它们有各自独立的虚拟地址空间，所以要实现共享数据，必须要有显式的 IPC 机制。事件驱动程序创建它们自己的并发逻辑流，这些逻辑流被模型化为状态机，用 I/0多路复用来显式地调度这些流。因为程序行在一个单一进程中，所以在流之间共享数据速度很快而且很容易。线程是这些方法的混合。同基于进程的流一样，线程也是由内核自动调度的。同基千 I/0 多路复用的流一样，线程是运行在一个单一进程的上下文中的，因此可以快速而方便地共享数据 。

无论哪种并发机制，同步对共享数据的并发访问都是一个困难的问题。提出对信号量的P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者-消费者程序中有限缓冲区和读者-写者系统中的共对象这样的资源访问进行调度。一个并发预线程化的 echo 服务器提供了信号摄使用场景的很好的例子。

并发也引入了其他一些困难的问题。被线程调用的函数必须具有一种称为线程安全的属性。我们定义了四类线程不安全的函数，以及一些将它们变为线程安全的议。可重入函数是线程安全函数的一个真子集，**它不访问任何共享数据**。可重入函数通常比不可重入函数更为有效，因为它们不需要任何同步原语。竞争和死锁是并发程序中出现的另一些困难的问题。**当程序员错误地假设逻辑流该如何调度时， 就发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。**