# Chapter 2 Representing and Manipulating Information 信息的表示和处理

![Untitled](Chapter%202%20Representing%20and%20Manipulating%20Informatio%206371b8cc706b416282796234c48af7fc/Untitled.png)

### 2.1.3 **Addressing and Byte Ordering**

大端和小端：一个数据其本身的顺序和在存储空间中存放一致性的差别

- 大端：顺序相反 IBM/Oracle多为此类（批判: 😆）
- 小端：顺序一致。Intel处理器多为此类, **ios和安卓也都是运行在小端模式**

例如 0x01234567 自身顺序是高(01) → 低(67)，

其在内存中存储的位置是0x100到0x103（四个字节），所以大小端如下图代表

![大小端](Chapter%202%20Representing%20and%20Manipulating%20Informatio%206371b8cc706b416282796234c48af7fc/Untitled%201.png)

大小端

<aside>
💡 其实私下猜猜出现这个问题的原因是因为数据用二进制表示的时候是从右往左位数增加，例如：  高位 01110111101011011 地位。而描述存储系统的时候又是从左往右增加，所以……

</aside>

### 2.2.1 Integral  Data Type

- 和机器类型相关的整数也就是`Long`

### **2.2.3 Two's-Complement Encodings 补码编码（负整数的理解方式）**

> **个人理解：**如果是signed Integer，则首位为1表示赋值，如果是w位宽，则首位表示负的2的w次方，后续的w-1位是正值，用来抵消首位的负值，所以：如果w=4时候
> 
> 
>  1000 = -8
> 1001 = -8 +（1）= -7
> 1111= -8+4+2+1 = -1
> 可以理解称如果首位是1，则在数轴的起点被拉到了 距离原点（0）最远的-2W次方处，然后首位之后的位数就相当于就位置不断往原点（0）处拉近。因此如果全部是0，则辣的最少，离原点最远；如果全部是1，则最靠近原点，也就是-1 了。
> 

补码的范围是不对称的: I*TMin* I= I*TMax* I+1, 也就是说， *TMin* 没有与之对应的正数。

这里的TMin也就是-2W次方。

之所以会有这样的不对称性是因为有一半的位模式表示负数（此时首位设置成1），这些都是非零的；而另一半表示非负数（此时包含了0），所以真正有数值的个数会比负数少一个。

<aside>
💡 所以：注意一 1 和 UMa工有同样的位表示 一一一个全 1 的串。
数值 0 在两种 表示方式中都是全 0 的串 。

</aside>

### **2.2.4 Conversions between Signed and Unsigned 有符号数和无符号数之间的转换**

```c
short int v = -12345;
    unsigned  short uv = (unsigned short) v;
    printf("v = %d, uv = %u\n", v, uv); // v = -12345, uv = 53191
```

个人理解：在转换的时候，只是将首位的符号位进行转换，而后面的位并不改变。所以 -12345与53191只是首位的差异，后面的位数表示都是一样的

<aside>
💡 对于大多数 C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规 则是:数值可能会改变，但是**位模式不变**。

</aside>

![Untitled](Chapter%202%20Representing%20and%20Manipulating%20Informatio%206371b8cc706b416282796234c48af7fc/Untitled%202.png)

> 总结一下，我们考虑无符号与补码表示之间互相转换的结果。对千在范围 O~x~ TMaxw 之内的值 x 而言，我们得到 T2队 (x)=x 和 U2兀 (x) =x 。也就是说，在这个范 围内的数字有相同的无符号和补码表示 。 对千这个范围以外的数值，转换需要加上或者减 去沪。例如，我们有 T2Uw(-l)= -1+2w=UMax心 最靠近 0 的负数映射为最大的无 符号数。在另一个极端，我们可以看到 T2Uw(TMinw) =— zw- 1+ 2三= zw-i = TMaxw+ 1 最小的负数映射为一个刚好在补码的正数范围之外的无符号数。使用图 2-15 的示 例，我们能看到 T2U16(—12 345)= 65 563+ —12 345=53 191。
> 

### **2.2.5 Signed versus Unsigned in C**

当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么 C 语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执 行这个运算。

后面的内容，特别是关于浮点的章节，跳过了……