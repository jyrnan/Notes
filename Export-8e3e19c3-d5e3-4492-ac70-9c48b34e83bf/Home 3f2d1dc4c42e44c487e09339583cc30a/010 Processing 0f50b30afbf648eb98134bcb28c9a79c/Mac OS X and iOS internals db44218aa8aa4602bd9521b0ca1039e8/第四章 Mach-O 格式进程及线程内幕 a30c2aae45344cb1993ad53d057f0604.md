# 第四章 Mach-O 格式进程及线程内幕

# 4.2 可执行文件文件

![Untitled](%E7%AC%AC%E5%9B%9B%E7%AB%A0%20Mach-O%20%E6%A0%BC%E5%BC%8F%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%B9%95%20a30c2aae45344cb1993ad53d057f0604/Untitled.png)

![Untitled](%E7%AC%AC%E5%9B%9B%E7%AB%A0%20Mach-O%20%E6%A0%BC%E5%BC%8F%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%B9%95%20a30c2aae45344cb1993ad53d057f0604/Untitled%201.png)

Mac支持以上三种可执行文件

<aside>
💡 ELF是Linux和Unix所支持的可执行文件，Mac并不支持，对应的是Mach-O

</aside>

# 4.3 通用二进制格式

Mac OS X的创新“通用二进制（Universal Binary），其实就是各种二进制文件的打包文件：文件头后依次拷贝了每一种支持架构的二进制文件。

又叫”胖二进制“，其处理工具叫lipo可以提取删除指定架构的二进制代码

![Untitled](%E7%AC%AC%E5%9B%9B%E7%AB%A0%20Mach-O%20%E6%A0%BC%E5%BC%8F%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%B9%95%20a30c2aae45344cb1993ad53d057f0604/Untitled%202.png)

## 4.3.1 Mach-O二进制格式

Unix通用二进制格式： Executable and library Format（ELF）

Mac独占格式： Mach-O ← NeXTSTEP遗产

![Untitled](%E7%AC%AC%E5%9B%9B%E7%AB%A0%20Mach-O%20%E6%A0%BC%E5%BC%8F%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%B9%95%20a30c2aae45344cb1993ad53d057f0604/Untitled%203.png)

<aside>
💡 可以通过otool来查看Mach-O文件

</aside>

## 4.3.2 加载命令

Mach-O头文件中包含了详细的指令用来指导如何设置和加载二进制数据，称为“加载命令”

加载过程在内核部分负责新进程的基本设置——分配虚拟内存，创建主线程以及处理任何可能的代码签名/加密工作。对于动态链接的可执行文件，真正的库加载和符号解析的工作都是通过LC_LOAD_DYLINKER命令指定的动态链接器在用户状态完成。

# 4.4 动态库

## 4.4.1 启动时库的加载

OS X上几乎所有的程序都是动态链接的。Mach-O镜像中有很多“空洞”——及对外部的库和符号的引用——需要在启动时填补，这个工作有动态链接器来完成，这个过程也称之为符号绑定（binding）

通常使用的/usr/lib/dyld作为动态链接器。所要完成的工作就是查找进程中所有的符号和库的关系，然后解决这些关系，这个过程必须**递归**地完成。

LibSystem库是所有二进制的绝对先决条件

### 共享库缓存

是dyld支持的另一个机制，指的是一些库经过预先链接，然后保存在磁盘的一个文件中。在iOS中格外重要。

## 4.4.2 库的运行时加载

一般情况：通过 #include 包含头文件解决所有的依赖条件后才能加载执行

另一种情况：通过<dlfcn.h>头文件提供的函数在运行时加载库

> Mac OS有一个有趣的特性： 可以定义符号为“weak”。如果这类符号解析错误不会引起程序错误，动态链接器将这个符合设置成NULL（Mac 独有？）
> 

## 4.4.3 dyld的特性

### 1. 两级名称空间

### 2. 函数拦截 - OC的method swizzling？

# 4.5 进程地址空间

## 4.5.1 进程入口点

还是“main”函数，但是多了一个apple参数，并且被扩展成两个，后者用于给进程地址空间增加一些随机性。参数在Mach- O加载时由内核初始化成随机值。

Cocoa的应用程序也是标准的C main()，但是随后将main实现成NSApplicationMain()包装，然后通过它进入Obective-C的编程模型

## 4.5.2 地址空间布局随机化

固定的空间地址不够安全 ”破解一次，随处破解“

地址空间布局随机化（ASLR）的技术避免攻击的有效保护。每次启动空间地址都简单的随机化——知识偏移，不是搅乱。基本布局——程序文本，数据和库——仍然一样。实现方法是通过内核将Mach- O的段平移某个随机系数。

Lion和iOS4.3是第一个完整支持ASLR的系统

# 4.6 进程内存分配（用户态）

和所有的操作系统一样，OS  X提供了两种类型的内存分配：

- 基于栈：通常是程序的自动变量
- 基于堆：通常是动态内存

> 在内核层面既没有用户堆，也没有栈，只有“页面”的概念
> 

## 4.6.1 alloca()

这个函数和malloc()一样，区别在于这个函数返回的指针式栈上的地址，而不是堆中

可以解决好内存泄漏问题

## 4.6.2 堆分配

堆事由C语言运行时库维护的用户态数据结构，通过堆的使用，程序可以不用直接在页面的层次处理内存分配。

“堆heap”这个术语来源于背后使用的数据结构——二叉堆。每个操作系统对堆管理都有自己的特色，分别采用了完全不同的方式。

Darwin的LibC采用了方法特币适合于Objective-C Runtime。

# 4.7 线程

现在OS都将调度对象从进程转向线程

特别是多核CPU 适合多线程的运行： 多个处理器核心共享同样的cache和RAM，这是线程之间共享虚拟内存的基础。

UN*X系统采纳了POSIX线程模型，Mac OS X也引入了一些高层的API，例如Grand Central Dispatch。

### 1. POSIX线程

### 2.Grand Central Dispatch

Snow Leopard引入的一套新的API，GCD自己维护了一个底层的线程库实现，支持兵法和异步的执行。

工作单元实现成函数或**函数块 ^代表的block获得了很好的支持。**